# 04.1-运算符

## 一 JS 运算符分类

根据操作的数据数目，可以将操作符划分为一元运算符、二元运算符、三元运算符等：

- 一元运算符：即只能操作一个值的运算符
  - 正号、负号、平方、位运算
  - 自增 `++` ，自减 `--`
  - `delete`、`typeof` `void` 等也被归纳为运算符
- 二元运算符：即操作两个值的运算符
  - 加、减、乘、除、模
  - ES6 新增指数运算符：`2 ** 3` 结果为 8
- 三元运算符：`表达式？值 1：值 2`，（表达式成立取值 1，不成立取值 2）

需要注意的是，使用运算符可能出现数据类型的转换，如类似自增自减这样的运算符会遵循下列规范：

- 对于有效数字字符串会先转换为数字，再运算
- 对于不包含有效数字的字符串，其值会设置为 NaN
- 对于 Boolean 类型，false 会先转换为 0，true 会转换为 1 再运算
- 在操作对象时，先调用对象的 valueOf() 方法返回一个可供操作的值，然后依据该值根据上述规律执行操作

## 二 常见运算符的使用

### 2.1 自增自减

一元运算符中较为特殊的是自增自减运算符：

- i++：当 i++参与运算，先将 i 原来的值赋值给变量，自己再加 1（先赋值后计算）
- ++i：当++i 参与运算，先将变量加 1，然后将加 1 后的值赋值给另外一个变量（先计算后赋值）

```js
let num1 = 2
let num2 = 20
let num3 = num1-- + num2
let num4 = num1 + num2

console.log(num3) // 22
console.log(num4) // 21
```

### 2.2 位运算

在计算机内存中，使用 0 与 1 这样的进制位来表示数据，每一个 0 或者 1 代表一位。JS 的数值以 64 位格式存储，但是位运算会先将 64 位值转换为 32 位整数再进行操作，最后将结果转换回 64 位，所以对于开发者来说，仿佛不存在 64 位整数存储格式，只需要考虑 32 位整数即可。

对于有符号的整数，32 位数据从右至左开始，前 31 位用于表示整数的值，第 32 位是符号位（sign bit）。

以下示例中，数值 18 的二进制表示是：

```txt
# 8 的二进制
# 从右至左第32位（左侧第1个）为符号位，0表示正数，1表示负数
# 数值中没有用到的位用 0 来填充

0000 0000 0000 0000 0000 0000 0001 0010
```

其实我们可以看到有效位只有 5 位，即：`1 0010` 这决定实际的值。

$10010 = 2^4 \times 1 + 2^3 \times 0 + 2^2 \times 0 + 2^1 \times 1 + 2^0 \times 0$

由此看到，正数以真正的二进制格式存储，31 位中每一位都是 2 的幂。

负数使用的是二进制补码进行存储的：

- 第一步：先求其绝对值的二进制码，如求 -18 的补码，要先得到其绝对值 18 的二进制码：`0000 0000 0000 0000 0000 0000 0001 0010`
- 第二步：求绝对值二进制的反码，即 0 和 1 互换，上述二进制位的反码为：`1111 1111 1111 1111 1111 1111 1110 1101`
- 第三步：反码加 1，得到最终 -18 的二进制位表示结果：`1111 1111 1111 1111 1111 1111 1110 1110`

但是 ECMAScript 隐藏了很多细节，在以二进制输出一个负数时，其实是输出这个负数绝对值的二进制码，并添加一个符号，这样处理更符合现实显式逻辑：

```js
let num = -18
console.log(num.toString(2)) // "-10010"
```

贴士：

- 由于 ECMAScript 做位运算时，会进行 64 与 32 位的转换，这会导致一个后果，NaN 和 Infinity 的值在位操作中，会被视为 0 来处理。
- 对非数值进行位操作时，会先使用 Number() 方法将其自动转换为一个数值，然后进行位操作

常见的位操作：

- `~` (按位非 NOT）：操作数为 1 则转换为 0，为 0 则转换为 1。其本质其实是操作数的负值减一，如 25 执行按位非，得到 -26，示例：`console.log(~25)`
- `&` (按位与 AND）：操作数都为 1 则转换为 1，其余情况都为 0，示例结果为 1：`console.log(25 & 3);`
- `|` (按位或 OR）：操作数都为 0 则按位或结果为 0，其余情况都为 1，示例结果为 1：`console.log(25 | 3);`
- `^` (按位异或 XOR）：操作数不同为 1，相同为 0，示例结果为 26：`console.log(25 ^ 3);`
- `<<` (左移)：位向左移动，右侧空出来的空位使用 0 补充。注意：左移不会影响操作数的符号位
- `>>` (右移)：位向右移动，空位使用符号位的值来填充，所以右移动会保留符号位。无符号的右移动使用 `>>>` 表示，该操作会将操作数的所有 32 位都向右移动：如果是正数，则有无符号的右移动，结果都是相同的；如果是负数，无符号右移以 0 补充空位！

### 2.3 布尔运算

布尔操作包括：逻辑非、逻辑与。

逻辑非：即使用 ! 取反，要注意的是 NaN、null、undefined、'' 取反得到的都是 true。

逻辑与：使用 && ，两个操作数中有一个操作数为 false，则结果就位 false，两个操作数都为 true，结果才为 true。注意逻辑与不一定返回布尔值：

- 如果第一个操作数是对象，则返回第二个操作数；
- 如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象；
- 如果两个操作数都是对象，则返回第二个操作数；
- 如果有一个操作数是 null，则返回 null；
- 如果有一个操作数是 NaN，则返回 NaN；
- 如果有一个操作数是 undefined，则返回 undefined。
- 逻辑或：使用 || ，两个操作数都为 false，结果才为 false，否则都为 true。同样逻辑或也不一定返回布尔值：
- 如果第一个操作数是对象，则返回第一个操作数；
- 如果第一个操作数的求值结果为 false，则返回第二个操作数；
- 如果两个操作数都是对象，则返回第一个操作数；
- 如果两个操作数都是 null，则返回 null；
- 如果两个操作数都是 NaN，则返回 NaN；
- 如果两个操作数都是 undefined，则返回 undefined。

> 短路操作：第一个操作数能够决定结果，就不会再对第二个操作数求值，逻辑与就是短路操作

所以下面的代码就不会报错：

```js
let found = false
let result = found && someUndefinedletiable // 不会发生错误，使用逻辑或 || 就会发生错误
console.log(result) // 会执行（ "false"）
```

### 2.4 加减乘除与取模

`+` 表示加法，遵循以下规则：

- 如果有一个操作数是 NaN，则结果是 NaN；
- Infinity 加 Infinity，结果是 Infinity；-Infinity 加 -Infinity，结果是-Infinity；Infinity 加 -Infinity，结果是 NaN；
- 如果是 +0 加 +0，则结果是 +0；如果是 -0 加 -0，则结果是 -0；如果是 +0 加 -0，则结果是 +0。
- 如果有一个操作数是字符串，那么就要应用如下规则：
- 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；
- 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。
- 如果有一个操作数是对象、数值或布尔值，则调用它们的 toString() 方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于 undefined 和 null，则分别调用 String() 函数并取得字符串"undefined"和"null"。

`-` 表示减法，遵循以下规则：

- 如果有一个操作数是 NaN，则结果是 NaN；
- Infinity 减 Infinity 以及 -Infinity 减 -Infinity，结果都是 NaN；Infinity 减 -Infinity，则结果是 Infinity；-Infinity 减 Infinity，则结果是-Infinity；
- 如果是 +0 减 +0，则结果是 +0；如果是 +0 减 -0，则结果是 -0；如果是 -0 减 -0，则结果是 +0；
- 如果有一个操作数是字符串、布尔值、null 或 undefined，则先在后台调用 Number() 函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN，则减法的结果就是 NaN；
- 如果有一个操作数是对象，则调用对象的 valueOf() 方法以取得表示该对象的数值。如果得到的值是 NaN，则减法的结果就是 NaN。如果对象没有 valueOf() 方法，则调用其 toString() 方法并将得到的字符串转换为数值

`*` 表示乘法，在处理特殊值的情况下，乘法操作符遵循下列特殊的规则：

- 如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了 ECMAScript 数值的表示范围，则返回 Infinity 或-Infinity；
- 如果有一个操作数是 NaN，则结果是 NaN；
- 如果是 Infinity 与 0 相乘，则结果是 NaN；
- 如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号；
- 如果是 Infinity 与 Infinity 相乘，则结果是 Infinity；
- 如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。

`/` 表示除法，也遵循类似规则：

- 如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果商超过了 ECMAScript 数值的表示范围，则返回 Infinity 或-Infinity；
- 如果有一个操作数是 NaN，则结果是 NaN；
- 如果是 Infinity 被 Infinity 除，则结果是 NaN；
- 如果是零被零除，则结果是 NaN；
- 如果是非零的有限数被零除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号；
- 如果是 Infinity 被任何非零数值除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号；
- 如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。

`%` 表示取模，特殊值处理规则如下：

- 如果操作数都是数值，执行常规的除法计算，返回除得的余数；
- 如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN；
- 如果被除数是有限大的数值而除数是零，则结果是 NaN；
- 如果是 Infinity 被 Infinity 除，则结果是 NaN；
- 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；
- 如果被除数是零，则结果是零；
- 如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。

贴士：Math.pow() 是指数操作，但是 ES7 推出了指数运算符

```js
console.log(Math.pow(3, 2); // 9
console.log(3 ** 2); // 9
```

### 2.5 关系运算符

进行关系比较时，也会出现数据不是正常数值的比较情况：

- 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。
- 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。
- 如果一个操作数是对象，则调用这个对象的 valueOf() 方法，用得到的结果按照前面的规则执行比较。如果对象没有 valueOf() 方法，则调用 toString() 方法，并用得到的结果根据前面的规则执行比较。
- 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较

注意：字母比较大小比较的是其字符编码值；`"23" < "3"`结果是 true，因为同样比较的也是编码值，2 的编码值是 50，3 是 51

在比较相等时，额外要注意：

- null 和 undefined 是相等的
- 要比较相等性之前，不能将 null 和 undefined 转换成其他任何值
- 如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。即使两个操作数都是 NaN，相等操作符也返回 false
- 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true；否则，返回 false。

`===`表示全等于，表示只有在两个操作数未经转换就相等的情况下才返回 true。

## 三 运算符优先级

```txt
1   ()
2   !、-（负数）、++、-- （正数省略+）（一元运算）
3   *、/、%
4   +、- （加，减）（二元运算）
5   <、<=、<、>= （一级逻辑运算）
6   ==、!=、===、!==、 （二级逻辑运算）
7   && （三级级逻辑运算）
8   ||
9   ?: （三元运算）
10  =、+=、-=、*=、/=、%= （赋值运算）
```

## 四 知识补充

### 4.1 溢出与下溢

JS 的算术运算在溢出（overflow）或者被零整除时不会报错，而是会返回一个数字上限，表示无穷大，即：`+Infinity`、`-Infinity`。

```js
console.log(15 / 0) // Infinity
console.log(-15 / 0) // -Infinity
```

JS 的算术运算在下溢（underflow）时候也不会报错，而是直接返回 0。下溢即结果值无限趋近于 0：

```js
console.log(0.1 / 10e1000) // 0
```

`0/0`是没有意义的，会返回一个非数字 NaN。无穷大除以无胸大、负数做开放运算、不是数字的数据进行算术运算，都会返回 NaN：

```js
console.log(0 / 0) // NaN
```

### 4.2 1.2 0.1+0.2 == 0.3

先看示例：

```js
console.log(0.1 + 0.2 == 0.3) // false
console.log(0.1 + 0.3 == 0.4) // true
```

上述并不是 JS 语言的特例，几乎所有现代编程语言都有上述特性，因为他们都使用了 IEEE-754 浮点数表示法：0.1 与 0.2 在转换为二进制时即已经出现了精度丢失。

### 4.3 直接量表达式

```js
// 数组直接量
let arr = [1, 2, 3]

// 对象直接量
let obj = {
  name: 'lisi',
  age: 20,
}

// 函数直接量
let fn = function () {}
```

### 4.4 && || 运算符的短路

&& || 运算符可以用来填充默认值：

```js
// 这样设计变量可以做为默认值处理
let p = 'Angel' || 'Demon'
console.log(p)
```
