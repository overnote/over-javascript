# 09.1-面向对象-思想概念

## 一 面向对象初识

### 1.1 面向对象概念

软件开发领域具有两种开发思想：

- 面向过程：比如经典的 C 语言即是面向过程语言。如果需要写一个功能，直接按照操作过程一步一步实现即可。
- 面向对象：比如经典的 Java 语言即是面向对象语言。任何功能都是由一个已经存在的工具来提供，由不同工具的组合实现一个完整系统

面向过程编程只包含过程的调用，没有高级抽象，类其实可以看做一种设计模式，他可以把过程化风格的意大利面代码转换成结构清晰、组织良好的代码。类似的，函数式编程也可以看做一种设计模式。

面向对象有优点也有缺点，使用对象必须存在实例化的过程，造成了一定的性能损失，但是其优点也很明显，让大型工程更加易于维护和管理。

> OO：面向对象，即 Object Oriented
> OOP：面向对象编程，即 Object Oriented Programming
> OOA：面向对象分析，即 Object Oriented Analysis
> OOD：面向对象设计，即 Object Oriented Design

贴士：有些语言比如 Java 并不会给你选择的机会，类是必须的，万物皆对象。而 C++、JavaScript 这种提供了面向过程、面向对象两种语法，且可以混合使用。

### 1.2 面向对象的三大特性

面向对象三大特性：

- **封装**：隐藏对象的属性和实现细节，仅对外提供公共访问方式。封装可以将变化隔离，便于使用，提高复用性和安全性。
- **继承**：通过父子关系引用，子类无需书写父类成员，也能使用父类的成员。继承主要提高代码复用性。
- **多态**：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。多态用来提升程序的拓展性。

### 1.3 面向对象的五个基本原则

- 单一职责原则 SRP（Single Responsibility Principle）：类的功能要单一
- 开放封闭原则 OCP(Open－Close Principle)：一个模块对于拓展是开放的，对于修改是封闭的
- 里式替换原则 LSP(the Liskov Substitution Principle LSP)：子类可以替换父类出现在父类能够出现的任何地方
- 依赖倒置原则 DIP(the Dependency Inversion Principle DIP)：高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。
- 接口分离原则 ISP(the Interface Segregation Principle ISP)：设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。

## 二 JavaScript 面向对象

### 2.0 JavaScript 中的对象

JS 的对象有两种定义形式：

- 声明式(直接量、文字形式)：`const p = {name: 'zs'}`
- 构造形式：`const p = new Person('zs')`

与 Java 中描述的万物皆对象不同，在 JavaScript 中，对象是无序属性的集合，其属性可以包含基本值、对象、函数等，即：对象是由一系列无序的 key-value 对组成，value 可以是多种数据类型。

null 和 undefined 没有对应的构造形式，它们只有文字形式。相反，Date 只有构造，没有文字形式。

对于 Object、Array、Function 和 RegExp（正则表达式）来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量。

### 2.1 JavaScript 的类与实例

> **类**：类是用于创建对象的模板。他们用代码封装数据以处理该数据。JS 中的类建立在原型上，但也具有某些语法和语义未与 ES5 类相似语义共享。类与引用类型相似，但不是一个概念，其意义在于约束一个事物的模板，引用类型则是一种数据类型！
> **实例**：通过 new 操作符创建，其实就是一个引用的值，经常称某个引用类型的**实例**为对象。

解析：一些编程语言默认提供 Stack 栈类，其实 Stack 类只是一个抽象，用来描述栈需要做的事，但是其本身并不是一个栈，必须实例化后才能进行操作。

JavaScript 是一门面向对象的编程语言，但是其缺少传统面向对象语言的基本特征，如：类、接口。所以我们不能简单的将类、引用类型等混为一谈，JS 只是提供了一些近似类的语法。

JavaScript 创建对象示例：

```js
// now：实例；Date()：构造函数，在 Java 中我们也可以称 Date 为类
let now = new Date()
```

Java 等语言中，类表现出来的都是复制行为，JavaScript 的对象机制并不会自动执行复制行为。简单来说，JavaScript 中只有对象，并不存在可以被实例化的“类”。一个对象并不会被复制到其他对象，它们会被关联起来。

JavaScript 中只有对象，没有类！

### 2.2 构造函数

> 构造函数：构造类实例的一个特殊方法，用来描述对象内部数据结构，其任务是初始化实例所需要的信息（状态）

注意：构造函数只是对对象内部数据的描述，并没有达到创建对象的作用，`new`操作才是创建了对象。

示例：

```js
// Person 构造函数：名称与类名一致，且大写
function Person(name, age) {
  this.name = name // 不添加 this 限定就会让 name 造成污染：创建的多个不同实例，其 name 都一样
  this.age = age
}

let p = new Person('lisi', age)
console.log(p.name)
```

### 2.3 原型

在 JS 中，创建一个类依赖于构造函数、原型两个条件。JavaScript 中的对象有一个特殊的 `[[Prototype]]` 内置属性，其实就是对于其他对象的引
用。几乎所有的对象在创建时 `[[Prototype]]` 属性都会被赋予一个非空的值。（至于原型出现的原因将会在下一节创建 JS 对象中详细说明）。

示例：

```js
// Person 构造函数：名称与类名一致，且大写
function Person(name, age) {
  this.name = name // 不添加 this 限定就会让 name 造成污染：创建的多个不同实例，其 name 都一样
  this.age = age
}

// 构造函数的原型：用于挂载类的实例方法
Person.prototype.sing = function () {
  console.log(this.name + '在唱歌...')
}
```

上述代码完整、标准展现了 JS 中的一个类 Person，一个标准的类包括两部分：

- 构造函数：首字母大写，与类名相同，内部包含该类的通用属性
- 构造函数的原型：每个构造函数都具备的属性 prototype，内部包含该类的通用方法

有了类，现在就可以通过类创建对象了：

```js
let p1 = new Person('张三', 30)
console.log(p.age) // 30
p1.sing() // 张三在唱歌...

let p2 = new Person('张三', 30)
console.log(p.age) // 30
p2.sing() // 张三在唱歌...
```

构造函数中的 this，其实就代表了对象的实例！

### 2.4 成员

我们通常称呼一个类的字段、函数为成员，类的成员通常有两部分：

- 属性：即类包含的一些键值
- 方法：即类包含的一些函数。用类或对象来调用的函数，我们一般称之为方法

方法可以挂载在构造函数的原型上，也可以直接挂载在构造函数上，那么此时就可以分为：

- 实例方法：由类创建的实例对象调用，如示例中的 sing 方法
- 静态方法：也称为类方法，由类本身调用，挂载在构造函数上

静态方法示例：

```js
Person.eat = function () {
  console.log('eat....')
}

Person.eat()
```

贴士：上述的成员、方法的定义是以常见的 Java、Python 等面向对象语言的对象设计理论定义的。在 JavaScript 中，从严格意义来说并不准确。JS 访问一个属性获得的函数与常规定义的函数没有任何区别！虽然对象属性获得的函数具有 this 引用，且这些 this 确实会指向调用位置的对象引用，但是这种用法从本质上来说并没有把一个函数变成一个“方法”，因为 this 是在运行时根据调用位置动态绑定的，所以函数和对象的关系最多也只能说是间接关系。

```js
function foo() {
  console.log('foo')
}
var someFoo = foo // 对 foo 的变量引用
var myObject = {
  someFoo: foo,
}
foo // function foo(){..}
someFoo // function foo(){..}
myObject.someFoo // function foo(){..}
```

someFoo 和 myObject.someFoo 只是对于同一个函数的不同引用，并不能说明这个函数是特别的或者“属于”某个对象。如果 foo() 定义时在内部有一个 this 引用，那这两个函数引用的唯一区别就是 myObject.someFoo 中的 this 会被隐式绑定到一个对象。无论哪种引用形式都不能称之为“方法”。

或许有人会辩解说，函数并不是在定义时成为方法，而是在被调用时根据调用位置的不同成为方法。即便如此，这种说法仍然有些不妥。最保险的说法可能是，“函数”和“方法”在 JavaScript 中是可以互换的。----摘自《你不知道的 JavaScript》(上卷)第 3 章。

ES6 增加了 super 引用，一般来说会被用在 class 中。super 的行为似乎更有理由把 super 绑定的函数称为“方法”。但是再说一次，这些只是一些语义（和技术）上的微妙差别，本质是一样的。

即使你在对象的文字形式中声明一个函数表达式，这个函数也不会“属于”这个对象——它们只是对于相同函数对象的多个引用。

```js
var myObject = {
  foo: function () {
    console.log('foo')
  },
}
var someFoo = myObject.foo
someFoo // function foo(){..}
myObject.foo // function foo(){..}
```

### 2.5 成员的访问

成员可以使用点语法（属性访问）、[]（键访问）两种形式访问：

```js
const obj = {
  a: 2,
}
obj.a // 2
obj['a'] // 2
```

[]键访问可以接收的键值范围更广，可以接受任意 UTF-8/Unicode 字符串作为属性名，且可以动态加入一些变量：

```js
var myObject = {
  a: 2,
}
var idx
if (wantA) {
  idx = 'a'
}

console.log(myObject[idx]) // 2
```

数组有自己的一套访问方式，[]中是数值下标，也就是说值存储的位置。数组也是对象，所以数组也可以通过点语法、[]语法添加属性，但是不会改变 length 长度！！
