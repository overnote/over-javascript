# 02.4-并发模型-协程

## 一 理解协程

> 协程：也称为纤程（Coroutine）, 是一个特殊的函数，这个函数可以在某个地方挂起，并且可以重新在挂起处外继续运行。

协程与进程、线程相比并不是一个维度的概念，协程不是被操作系统内核所管理的，而是完全由程序所控制，也就是在用户态执行。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。

正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程（目前的协程框架一般都是设计成 1:N 模式）。

注意：

- 多个进程或一个进程内的多个线程是可以并行运行的
- 一个线程内的多个协程却是串行的，无论 CPU 有多少个核，因为协程本质上还是一个函数，当一个协程运行时，其它协程必须挂起
- 但是协程的切换过程只有用户态，即没有陷入内核态，因此切换效率比进程和线程高很多

协程自己会主动适时的让出 CPU，也就是说每个协程池里面有一个调度器，这个调度器是被动调度的。意思就是他不会主动调度。而且当一个协程发现自己执行不下去了（比如异步等待网络的数据回来，但是当前还没有数据到)，这个时候就可以由这个协程通知调度器，这个时候执行到调度器的代码，调度器根据事先设计好的调度算法找到当前最需要 CPU 的协程。切换这个协程的 CPU 上下文把 CPU 的运行权交个这个协程，直到这个协程出现执行不下去需要等等的情况，或者它调用主动让出 CPU 的 API 之类，触发下一次调度。

## 二 协程的优缺点

优点：

- 占用小：协程更加轻量，创建成本更小，降低了内存消耗，协程一般只占据极小的内存（2~5KB），而线城市 1MB 左右。虽然线程和协程都是独有栈，但是线程栈是固定的，比如在 Java 中，基本是 2M，假如一个栈只有一个打印方法，还要为此开辟一个 2M 的栈，就太浪费了。而 Go 的的协程具备动态收缩功能，初始化为 2KB，最大可达 1GB
- 运行效率高：线程切换需要从用户态->内核态->用户态，而协程切换是在用户态上，即用户态->用户态->用户态，其切换过程由语言层面的调度器（coroutine）或者语言引擎（goroutine）实现。
- 减少了同步锁：协程最终还是运行在线程上，本质上还是单线程运行，没有临界区域的话自然不需要锁的机制。多协程自然没有竞争关系。但是，如果存在临界区域，依然需要使用锁，协程可以减少以往必须使用锁的场景
- 同步代码思维写出异步代码

缺点：

- 无法利用多核资源：协程运行在线程上，单线程应用无法很好的利用多核，只能以多进程方式启动。
- 协程不能有阻塞操作：线程是抢占式，线程在遇见 IO 操作时候，线程从运行态 → 阻塞态，释放 cpu 使用权。这是由操作系统调度。协程是非抢占式，如果遇见 IO 操作时候，协程是主动释放执行权限的，如果无法主动释放，程序将阻塞，无法往下执行，随之而来是整个线程被阻塞。
- CPU 密集型不是长处：假设这个线程中有一个协程是 CPU 密集型的他没有 IO 操作，也就是自己不会主动触发调度器调度的过程，那么就会出现其他协程得不到执行的情况，所以这种情况下需要程序员自己避免。

应用场景：

- 高性能计算，牺牲公平性换取吞吐。协程最早来自高性能计算领域的成功案例，协作式调度相比抢占式调度而言，可以在牺牲公平性时换取吞吐
- IO Bound 的任务：虽然异步 IO 在数据到达的时候触发回调，减少了线程切换带来性能损失，但是该思想不符合人类的思维模式。异步回调在破坏点思维连贯性的同时也破坏掉了程序的连贯性，让你在阅读程序的时候花费更多的精力。但是协程可以很好解决这个问题。比如把一个 IO 操作 写成一个协程。当触发 IO 操作的时候就自动让出 CPU 给其他协程。要知道协程的切换很轻的。协程通过这种对异步 IO 的封装既保留了性能也保证了代码的容易编写和可读性。

## 三 协程的简单实现

ES6 提供了一种新的方法名叫 Generator。Generator 的执行过程可以被暂停和恢复，所以它被认为是 ES6 中的协程，但严格地说，Generator 只是半协程（semi-coroutine），因为虽然它可以主动放弃执行权，但是它并没有告知运行环境，下一步哪个协程会被调用。当一个 Generator 被调用时，它的代码并不会被执行，调用者得到的是它的观察者（Observer）。调用者通过调用这个观察者的方法，比如 next 方法，来执行 Generator 的代码。

```js
const Q = []
const Q_LEN = 10

function* produce() {
  while (Q.length < Q_LEN) {
    const item = Date.now()
    Q.push(item)
    console.log(`Item ${item} is produced`)
    if (Q.length === Q_LEN) {
      yield
    }
  }
}

function* consume() {
  while (Q.length > 0) {
    const item = Q.pop()
    console.log(`Item ${item} is consumed`)
    if (Q.length === 0) {
      yield
    }
  }
}

function bootstrap() {
  const producer = produce()
  const consumer = consume()
  while (true) {
    producer.next()
    consumer.next()
  }
}
bootstrap()
```

在上面代码中，produce 和 consume 是两个协程。bootstrap 方法是这两个协程的调用者，它首先获取 produce 和 consume 协程的观察者，然后循环调用观察者的 next 方法，从而使得生产者和消费者的关系持续运行。在循环过程中，如果 produce 检测队列已满，它就主动放弃执行权从而被暂停，consume 将获得执行权，如果 consume 检测队列已空，它就主动放弃执行权从而被暂停，produce 将重新获得执行权。
