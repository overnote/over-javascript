# 02.1-并发模型-多进程

## 一 进程概念

> 进程：就是二进制可执行文件在计算机内存中的运行实例，可以简单理解为：一个.exe 文件是个类，进程就是该类 new 出来的实例。
> 进程是操作系统最小的资源分配单位（如虚拟内存资源），所有代码都是在进程中执行的。

为了方便管理进程，每个进程都有自己的描述符，是个复杂的数据结构，我们称之为**进程控制块**，即 PCB(Process Control Block)。

PCB 中保存了进程的管理、控制信息等数据，主要包含字段有：

```txt
进程 ID（PID）：进程的唯一标识符，是一个非负整数的顺序编号
父进程 ID（PPID）：当前进程的父进程 ID
文件描述符表：即很多指向 file 接否提的指针
进程状态：就绪、运行、挂起、停止等状态
虚拟地址范围
访问权限
当前工作目录
用户 id 和组 id
会话和进程组
```

贴士：进程 ID 是可以重用的，当进程 ID 达到最大限额值时，内核会从头开始查找闲置的进程 ID 并使用最先找到的那一个作为新进程的 ID

## 二 进程创建

Unix 系统在启动后，会首先运行一个名为 init 的进程，其 PID 为 1。该进程是所有其他进程的父进程。

Unix 操作系统通过 `fork()` 函数能够创建多个子进程，从而能够提升计算机资源的利用率。此时调用者称为父进程，被创造出来的进程称为子进程。

- 每个子进程都是源自它的父进程的一个副本，它会获得父进程的数据段、堆、栈的拷贝，并与父进程共享代码段。
- 子进程对自己副本的修改对其父进程和兄弟进程都是不可见的，反之亦然。

创建的子进程可以直接开始运行，但是也可以通过 `exec()` 函数来加载一个全新的程序，此时子进程会丢弃现存的程序文本段，为加载的新程序重新创建栈、数据段、堆，我们对这一个过程称为执行一个新程序。

贴士：exec 并不是 1 个函数，是一系列 exec 开头的函数，作用都是执行新程序。

C 语言示例如下：

```c++
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(){

    pid_t pid;
    int r;

    // 创建子进程
    pid = fork();
    if (pid == -1){                   // 发生错误
        perror("fork发生错误 ");
        exit(1);
    }

    // 返回值大于0时是父进程
    if(pid > 0){
        printf("父进程: pid = %d, ppid = %d \n", getpid(),getppid());        // 父进程执行动作
        sleep(3);                       // 父进程睡眠，防止子进程还没运行完毕，父进程却直接退出了
    }

    // 返回值为0的是子进程
    if(pid == 0){

        printf("子进程: pid = %d , ppid = %d \n", getpid(),getppid());     // 子进程执行动作

        // 子进程加载一个新程序：系统自带的 echo程序，输出 hello world!
        char * execv_str[] = {"echo", "hello world!",NULL};
        int r = execv("/bin/echo", execv_str);    // 笔者的是mac，linux上为： "/usr/bin/echo"
  if (r <0 ){
   perror("error on exec");
   exit(0);
        }
    }
    return 0;
}
```

在 Go 语言中，没有直接提供 fork 系统调用的封装，而是将 fork 和 execve 合二为一，具体信息可以参见 Go 的 os 包。

```go
package main

import (
 "fmt"
 "os"
 "time"
)

func main() {

 fmt.Println("当前进程 ID：", os.Getpid())

 procAttr := &os.ProcAttr{
  Files: []*os.File{os.Stdin, os.Stdout, os.Stderr},
 }
 process, err := os.StartProcess("/bin/echo", []string{"", "hello,world!"}, procAttr)
 if err != nil {
  fmt.Println("进程启动失败：", err)
  os.Exit(2)
 } else {
  fmt.Println("子进程 ID：", process.Pid)
 }

 time.Sleep(time.Second)

}
```

根据该方式，就可以很容运行计算机上的其他任何程序，包括自身的命令行、Java 程序等等。

## 四 进程分类

进程分类：

- 用户进程：位于用户空间中，是程序执行的实例
- 内核进程：位于内核空间中，可以访问硬件

由于用户进程无法访问内核空间，所以无法直接操作硬件。内核会暴露一些接口提供给用户进程使用，让用户进程简介操作硬件，这便是系统调用。

内核为了保证系统的安全和稳定，为**CPU**特供了两个状态：

- 用户态：大部分时间 CPU 处于该状态，此时只能访问用户空间
- 内核态：当用户进程发起系统调用时，内核会将 CPU 切换到内核态，然后执行相应接口函数。

注意：这里的用户态和内核态是针对 CPU 的。

## 五 进程调度

同一时刻只能运行一个进程，但是 CPU 可以在多个进程间进行来回切换，我们称之为上下文切换。

操作系统会按照调度算法为每个进程分配一定的 CPU 运行时间，称之为时间轮片，每个进程在运行时都会认为自己独占了 CPU，如图所示：

![进程调度](../images/node/02-01.svg)

切换进程是有代价的，因为必须保存进程的运行时状态。

## 六 进程状态转换

进程在创建后，在执行过程中，其状态一直在变化。不同时代的操作系统有不同的进程模型：

- 三态模型：运行态、就绪态、等待态
- 五态模型：初始态、就绪态、运行态、挂起态（阻塞）、终止态

本笔记介绍五态模型。初始态是进程的准备节点，常与就绪状态结合来看，进程的状态转换图：  
![进程状态转换](../images/node/02-02.svg)

## 七 进程运行的问题

### 7.1 写时复制

父进程无法预测子进程什么时候结束，只有进程完成工作后，父进程才会调用子进程的终止态。

贴士：全盘复制父进程的数据相当低效，Linux 使用写时复制（COW：Copy on Write）技术来提高进程的创建效率。

### 7.2 进程回收

当一个进程退出之后，进程能够回收自己的用户区的资源，但是不能回收内核空间的 PCB 资源，必须由它的父进程调用 wait 或者 waitpid 函数完成对子进程的回收，避免造成系统资源的浪费。

> 孤儿进程：父进程先于子进程结束，则子进程成为孤儿进程，此时该进程会被系统的 init 进程领养
> 僵尸进程：子进程终止，但父进程未回收，子进程残留资源（PCB）于内核中，变成僵尸进程。

注意：由于僵尸进程是一个已经死亡的进程，所以不能使用 kill 命令将其杀死，通过杀死其父进程的方法可以消除僵尸进程，杀死其父进程后，这个僵尸进程会被 init 进程领养，由 init 进程完成对僵尸进程的回收。

## 八 进程间通信

### 8.0 进程间通信方式概述

Linux 环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程 1 把数据从用户空间拷到内核缓冲区，进程 2 再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。

![进程通信](../images/node/02-09.png)

在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套接字、命名管道等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用。现今常用的进程间通信方式有：

- 管道 (使用最简单)
- 共享映射区 (无血缘关系进程通信)
- 信号 (开销最小)
- 本地套接字 (最稳定)

Go 支持的 IPC 方法有：管道、信号、socket。

### 8.1 管道

管道是一种最基本的 IPC 机制，也称匿名管道，应用于有血缘关系的进程之间，完成数据传递。调用 C 的 pipe 函数即可创建一个管道。

![管道](../images/node/02-10.png)

管道有如下特质：

- 管道的本质是一块内核缓冲区
- 由两个文件描述符引用，一个表示读端，一个表示写端。
- 规定数据从管道的写端流入管道，从读端流出。
- 当两个进程都终结的时候，管道也自动消失。
- 管道的读端和写端默认都是阻塞的。

管道的实质是内核缓冲区，内部使用唤醒队列实现。

管道的缺陷：

- 管道中的数据一旦被读走，便不在管道中存在，不可反复读取。
- 数据只能在一个方向上流动，若要实现双向流动，必须使用两个管道
- 只能在有血缘关系的进程间使用管道。

Go 模拟管道的实现：

```go
 cmd1 := exec.Command("ps", "aux")
 cmd2 := exec.Command("grep", "apipe")

 var outputBuf1 bytes.Buffer
 cmd1.Stdout = &outputBuf1
 cmd1.Start()
 cmd1.Wait()    // 开始阻塞

 var outputBuf2 bytes.Buffer
 cmd2.Stdout = &outputBuf2
 cmd2.Start()
 cmd2.Wait()    // 开始阻塞

 fmt.Println(outputBuf2.Bytes())
```

当然也有一种管道称为命名管道（FIFO），它支持无血缘关系的进程之间通信。FIFO 是 Linux 基础文件类型中的一种（文件类型为 p，可通过 ls -l 查看文件类型）。但 FIFO 文件在磁盘上没有数据块，文件大小为 0，仅仅用来标识内核中一条通道。进程可以打开这个文件进行 read/write，实际上是在读写内核缓冲区，这样就实现了进程间通信，如图所示：

![FIFO](../images/node/02-11.png)

### 8.2 内存映射区

存储映射 I/O (Memory-mapped I/O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。从缓冲区中取数据，就相当于读文件中的相应字节；将数据写入缓冲区，则会将数据写入文件。这样，就可在不使用 read 和 write 函数的情况下，使用地址（指针）完成 I/O 操作。

使用存储映射这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过 mmap 函数来实现。

![内存映射区](../images/node/02-12.png)

### 8.3 信号

信号是 IPC 中唯一一种异步的通信方法，本质是用软件模拟硬件的中断机制，例如：在命令行终端按下某些快捷键，就会挂起或停止正在运行的程序。Go 中的 ginal 包提供了相关操作。

```go
 sigRecv := make(chan os.Signal, 1)                      // 创建接收通道
 sigs := []os.Signal{syscall.SIGINT, syscall.SIGQUIT}    // 创建信号类型
 signal.Notify(sigRecv, sigs...)
 for sig := range sigRecv {                              // 循环接收通道中的信号，通道关闭后，for 会立即停止
  fmt.Println(sig)
 }
```

### 8.4 socket

socket 即套接字，也是一种 IPC 方法，与其他 IPC 方法不同之处在于：可以通过网络连接让多个进程建立通信并相互传递数据，这使得通信不再依赖于在同一台计算机上。

## 九 进程同步

当多个子进程对同一资源进行访问时，就会产生竞态条件。比如：某一个数据，进程 A 对其进行执行`一系列`操作，但是在执行过程中，系统有可能会切换到另外一个进程 B 中，B 也对该数据进行`一系列`操作，那么在两个进程中操作同一份数据时，这个数据的结果值到底按照谁的来运算呢？

原子操作：如果执行过程中操作不能中断，那么就能解决上述问题，这样的操作称为原子操作（atomic operation）。这些只能被串行化访问或执行的资源或者某段代码被称为临界区（critical section）。Go 中 (sync/atomic 包提供了原子操作函数)。

注意：

- 所有的系统调用都是原子操作，即不用担心它们的执行被中断！
- 原子操作不能被中断，临界区是否可以被中断没有强制规定，只是保证了只能同时被一个访问者访问。

问题：如果一个原子操作无法结束，现在也无法中断，如何处理？

> 答案：内核只提供了针对二进制位和整数的原子操作（即保证细粒度），不会有上述现象。

互斥锁：  
在实际开发中，原子操作并不通用，我们可以保证只有一个进程/线程在临界区，该做法称为互斥锁（exclusion principle），比如信号量是实现互斥方法的方式之一，Golang 的 sync 包也有对互斥的支持。
