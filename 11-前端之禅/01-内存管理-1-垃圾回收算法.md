# 01-内存管理-1-垃圾回收算法

## 一 垃圾回收概念

### 1.1 内存的申请与释放

程序的运行需要操作系统提供内存支持，比如声明的变量、函数等都需要内存来进行存储。这些从操作系统申请的内存，在无需使用时必须进行释放，否则长时间占用操作系统资源，会引起不必要的性能降低、资源浪费，比如申请的变量已经在函数中使用完毕，其他地方无需使用，这个变量所占据的内存就需要释放！

简单来说：内存要一般有申请、使用、释放三个流程。

简单展示 C 语言内存的申请与释放操作：

```c++
#include <stdio.h>
#include <stdlib.h>

int main(){
    // 申请：申请一个数组内存来存储整型数据，元素个数为5
    int *arr = malloc(5 * sizeof(int));

    // 使用：制作数组数据，并打印数据
    for(int i = 0; i < 5; i++){
        arr[i] = i + 1;
    }
    for(int i = 0; i < 5; i++){
        printf("arr[%d]=%d\n", i, arr[i]);
    }

    // 释放：
    free(arr);

    // 此时再打印数据会报错
    return 0;
}
```

从上看出，C 语言是需要手动进行内存管理的，通过 `malloc()` 函数申请内存，通过 `free()` 函数释放内存，这对开发者来说造成了极大的心理负担，尤其在大型复杂项目上，内存的申请与释放更要小心。

### 1.2 自动销毁

一些适合快速开发普通业务的编程语言，如 Java、JavaScript 等语言的引擎内部会对内存进行自动申请、释放，能够有效提升开发效率，对程序中的不再使用内存进行回收的概念一般称呼为**垃圾回收**，垃圾回收工作依赖于一些复杂的算法，如标记清除、引用计数等，这些统称为：**垃圾回收机制**。

js 示例：

```js
// 申请
let arr = [1, 2, 3, 4, 5]

// 使用
arr.forEach((item) => {
  console.log(item)
})

// 释放:JS没有释放的API，是自动释放的，设置为null也不会直接触发释放，只是会清除其引用。
arr = null
```

## 二 垃圾回收算法

### 2.0 垃圾回收算法汇总

常见的基础垃圾回收算法有：

- 引用计数：记录申请的内存被引用的数，当被引用数为 0 时，销毁该内存。可以即时回收垃圾对象，但是无法解决循环引用问题。
- 标记清除：遍历所有对象，并标记活动对象，对没有被标记的对象进行清除。不能即时回收垃圾对象，但是可以解决循环引用问题，且会产生内存碎片。

此外，在使用上述算法进行回收时，还需要用到：标记整理、分代回收等算法机制。

### 2.1 引用计数

当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。

引用计算 GC 示例：

```js
let obj = { name: 'zs' }

let other = obj

obj = null
console.log(other.name) // zs

other = null
console.log(other.name) // 错误
```

### 2.2 引用计数的缺点

引用计数缺点：

```txt
程序暂停：使用引用计数进行垃圾回收时，程序会暂停运行，即 Stop The World，这显然是不合理的，应该最大限度减少程序的暂停
循环引用无法回收：应用计数无法解决循环依赖问题，会引起内泄露
开销大：程序需要使用一个数值监控数据的引用数，该数值需要时刻被监控，这会造成时间、空间的开销放大。
```

循环依赖即循环引用指的是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的引用：

```js
function problem() {
  let A = {}
  let B = {}
  A.other = B
  B.other = A
}
```

上述示例中，全局作用已经找不到 A 和 B，但是在函数内存，A 与 B 是互相引用者，即产生了循环引用，是无法使用引用计数进行清除的，因为当函数执行完毕后， A 和 B 还将继续存在，因为它们的引用次数永远不会是 0。假如这个函数被重复多次调用，就会导致大量内存得不到回收。

### 2.3 标记清除

标记清除算法（mark-and-sweep）是最常见的垃圾回收策略，包含两个阶段：

- 标记：遍历所有对象，标记活动对象（可达对象）
- 清除：遍历所有对象，清除没有标记的对象，也会抹除之前遍历设置的标记便于下次标记。

垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，即变量进入上下文时，比如在函数内部声明一个变量，这个变量会被加上存在于上下文中的标记，当变量离开上下文时，也会被加上离开上下文的标记。

垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。

一般称呼可以访问到的对象为可达对象（通过引用、作用域链访问到）。可达的标准是：从根（全局上下文）出发是否能够访问到该对象。

```js
let obj = { name: 'zs' }

let other = obj

obj = null

// 这里清除了obj对 {name: 'zs'} 的引用，但是other仍然在引用着obj
// 所以 {name: 'zs'} 仍然是可达的
console.log(other.name) // zs
```

如果该对象不可达，就会执行标记清除。所以在循环引用案例中，A，B 对象都离开了作用域，变为不可达，就不会再有循环应用的问题了。

### 2.4 标记清除缺点

当然标记清除也不是没有缺点，标记清除很容易造成**内存碎片**。
