# 02-性能优化-2-代码优化示例

## 一 基础语法优化

### 1.1 作用域

改进代码性能非常重要的一件事，可能就是要提防全局查询：随着作用域链中作用域数量的增加，访问当前作用域外部变量所需的时间也会增加。访问全局变量始终比访问局部变量慢，因为必须遍历作用域链。任何可以缩短遍历作用域链时间的举措都能提升代码性能。

```js
function updateUI() {
    let imgs = document.getElementsByTagName('img')
    for (let i = 0, len = imgs.length; i < len; i++) {
        imgs[i].title = '${document.title} image ${i}'
    }
    let msg = document.getElementById('msg')
    msg.innerHTML = 'Update complete.'
}
```

这个函数三个地方引用了全局 document 对象。如果页面的图片非常多，那么 for 循环中就需要引用 document 几十甚至上百次，每次都要遍历一次作用域链。 通过在局部作用域中保存 document 对象的引用，能够明显提升这个函数的性能，因为只需要作用域链查找。

通过创建一个指向 document 对象的局部变量，可以通过将全局查找的数量限制为一个来提高这个函数的性能：

```js
function updateUI() {
    let doc = document
    let imgs = doc.getElementsByTagName('img')
    for (let i = 0, len = imgs.length; i < len; i++) {
        imgs[i].title = '${doc.title} image ${i}'
    }
    let msg = doc.getElementById('msg')
    msg.innerHTML = 'Update complete.'
}
```

### 1.2 循环语句优化

循环会重复多次运行相同的代码，所以运行时间会自动增加。优化循环的基本步骤如下：

```txt
(1) 简化终止条件。因为每次循环都会计算终止条件，所以它应该尽可能地快。这意味着要避免属性查找或其他 O(n)操作。
(2) 简化循环体。循环体是最花时间的部分，因此要尽可能优化。要确保其中不包含可以轻松转移到循环外部的密集计算。
(3) 使用后测试循环。最常见的循环就是 for 和 while 循环，这两种循环都属于先测试循环。
  do-while就是后测试循环，避免了对终止条件初始评估 ，因此应该会更快。
```

示例：

```js
// 简单 for 循环
// for (let i = 0; i < values.length; i++) {
//   process(values[i])
// }

//  i 从 0 递增至数组 values 的长度。假设处理这些值的顺序不重要，那么可以将循环变量改为递减的形式
// 终止条件的计算复杂度也从查找 values.length的 O(n)变成了访问 0 的 O(1)。
// for (let i = values.length - 1; i >= 0; i--) {
//   process(values[i])
// }

// 整个循环可修改为后测试循环
let i = values.length - 1
if (i > -1) {
    do {
        process(values[i])
    } while (--i >= 0)
}
```

使用后测试循环时要注意，一定是至少有一个值需要处理一次。如果这里的数组是空的，那么会浪费一次循环，而先测试循环就可以避免这种情况。

如果循环的次数是有限的，那么通常抛弃循环而直接多次调用函数会更快。仍以前面的循环为例，如果数组长度始终一样，则可能对每个元素都调用一次 process()效率更高：

```js
// 抛弃循环
process(values[0])
process(values[1])
process(values[2])
```

如果不能提前预知循环的次数，那么或许可以使用一种叫作达夫设备（ Duff’s Device）的技术：

```js
// 来源： Jeff Greenberg 在 JavaScript 中实现的达夫设备
// 假设 values.length > 0
let iterations = Math.ceil(values.length / 8)
let startAt = values.length % 8
let i = 0
do {
    switch (startAt) {
        case 0:
            process(values[i++])
        case 7:
            process(values[i++])
        case 6:
            process(values[i++])
        case 5:
            process(values[i++])
        case 4:
            process(values[i++])
        case 3:
            process(values[i++])
        case 2:
            process(values[i++])
        case 1:
            process(values[i++])
    }
    startAt = 0
} while (--iterations > 0)
```

将 do-while 循环分成两个单独的循环后速度更快：

```js
// 来源： Speed Up Your Site（ New Riders， 2003）
let iterations = Math.floor(values.length / 8)
let leftover = values.length % 8
let i = 0
if (leftover > 0) {
    do {
        process(values[i++])
    } while (--leftover > 0)
}
do {
    process(values[i++])
    process(values[i++])
    process(values[i++])
    process(values[i++])
    process(values[i++])
    process(values[i++])
    process(values[i++])
    process(values[i++])
} while (--iterations > 0)
```

## 二 DOM 代码优化

### 2.1 实时更新最小化

涉及立即（实时）更新页面的显示，每次更新，无论是插入一个字符还是删除页面上的一节内容，都会导致性能损失。这是因为浏览器需要为此重新计算数千项指标，之
后才能执行更新。实时更新的次数越多，执行代码所需的时间也越长。反之，实时更新的次数越少，代码执行就越快：

```js
let list = document.getElementById("myList"),
item;
for (let i = 0; i < 10; i++) {
item = document.createElement("li");
list.appendChild(item);
item.appendChild(document.createTextNode('Item ${i}');
}
```

解决：

```js
let list = document.getElementById('myList'),
    fragment = document.createDocumentFragment(),
    item
for (let i = 0; i < 10; i++) {
    item = document.createElement('li')
    fragment.appendChild(item)
    item.appendChild(document.createTextNode('Item ' + i))
}
list.appendChild(fragment)
```

### 2.2 使用事件委托

### 2.3 注意 HTMLCollection

任何时候，只要访问 HTMLCollection，无论是它的属性还是方法，就会触发查询文档，而这个查询相当耗时。减少访问 HTMLCollection 的次数可以极大地提升脚本的性能。

```js
et images = document.getElementsByTagName("img");
for (let i = 0, len = images.length; i < len; i++) {
// 处理
}
```

这里的关键是把 length 保存到了 len 变量中，而不是每次都读一次 HTMLCollection 的 length 属性。在循环中使用 HTMLCollection 时，应该首先取得对要使用的元素的引用，如下面所示。这样才能避免在循环体内多次调用 HTMLCollection：

```js
let images = document.getElementsByTagName('img'),
    image
for (let i = 0, len = images.length; i < len; i++) {
    image = images[i]
    // 处理
}
```

这段代码增加了 image 变量，用于保存当前的图片。有了这个局部变量，就不需要在循环中再访问 images HTMLCollection 了。

编写 JavaScript 代码时，关键是要记住，只要返回 HTMLCollection 对象，就应该尽量不访问它。以下情形会返回 HTMLCollection：

```txt
调用 getElementsByTagName()；
读取元素的 childNodes 属性；
读取元素的 attributes 属性；
访问特殊集合，如 document.form、 document.images 等。
```

### 2.4 减少 DOM 操作方式 1

浏览器会将 DOM 与 JS 分开独立实现，如果使用 JS 操作 DOM 就像从一个区域跳转到了另外一个区域，每次跳转都会消耗性能，所以要尽量减少这种操作。
案例：

```js
//第一种操作DOM方式：
var div = document.getElementById('div')
console.time('hi')
//5000次来实现添加html
for (var i = 0; i < 5000; i++) {
    div.innerHTML += 'a'
}
console.timeEnd('hi') //chrome下输出hi: 241.7109375ms

//将innerHTML移除：
var div = document.getElementById('div')
console.time('hi')
var html = ''
for (var i = 0; i < 5000; i++) {
    html += 'a'
}
div.innerHTML = html
console.timeEnd('hi') //chrome下输出hi: 7.304931640625ms
```

### 2.5 减少 DOM 操作方式 2：使用节点克隆

创建多个相同节点时，推荐使用 clone，因为 clone 不是新创建节点，所以性能更高。
原本方式：

```js
console.time('hi')
var oUl = document.getElementById('ul')
for (var i = 0; i < 5000; i++) {
    var oLi = document.createElement('li')
    oLi.innerHTML = 'li'
    oUl.appendChild(oLi)
}

console.timeEnd('hi') //chrome下输出hi: 28ms
```

使用 clone 方式优化：

```js
console.time('hi')
var oUl = document.getElementById('ul')
var oLi = document.createElement('li')
oLi.innerHTML = 'li'
for (var i = 0; i < 5000; i++) {
    var newLi = oLi.cloneNode(true)
    oUl.appendChild(newLi)
}

console.timeEnd('hi') //chrome下输出hi: 8ms
```

## 三 资源加载代码优化

### 3.1 资源文件加载

整体的 html 文档是从上往下顺序执行的，但是引入的资源是并发请求的。

css 引入问题：

-   在 header 中使用 link 引入，会阻塞渲染
-   CSS 的加载会阻塞 JS 的执行。因为 JS 要操作 DOM，可能需要知道一些 CSS 属性，那么 CSS 加载完后再加载 JS，在逻辑上是正确的。
-   CSS 不阻塞外部脚本的加载

js 引入问题：

-   指直接诶引入的 js 阻塞页面的渲染
-   js 不阻塞资源的加载，可以更加精细的控制预加载过程，但是存在跨域问题！第三方库有：PreloadJS。

### 3.2 懒加载和预加载

-   懒加载：图片进入可视区之后才请求图片资源。
-   案例：瀑布流中的图片
-   实现：监听 scroll 事件，当图片到达可视区，图片 url 才会被加入。jQuery 中已经提供了更简便的 API。
-   预加载：与懒加载相反，是对资源的提前请求，当页面需要使用该资源时，可以直接从缓存中获取。
-   案例：九宫格抽奖，选中状态与非选中状态其实是提前都加载完毕的，这样才能

预加载实现：

-   方案一：html 中使用完整的 img 标签（JS 生成的 img 标签也可以），只需要将其隐藏即可，当需要展示时显示
-   方案二：使用 xhr 请求

### 3.3 重排与重绘

重排：页面元素的位置、形状发生了改变时就会触发，也称为回流（reflow）。

重绘：重排后的内容显示出来的过程叫做重绘。

注意：改变背景颜色不会触发重排，只会触发重绘，重排与重绘都会影响性能。

优化措施：尽量在 appendChild 前添加重排、重操作。

```js
//旧方式
console.time('hi')
for (var i = 0; i < 5000; i++) {
    var liObj = document.createElement('li')
    ulObj.appendChild(liObj)
    liObj.innerHTML = 'li'
}
console.timeEnd('hi') //750ms

//新方式
console.time('hi')
for (var i = 0; i < 5000; i++) {
    var liObj = document.createElement('li')
    liObj.innerHTML = 'li'
    ulObj.appendChild(liObj)
}
console.timeEnd('hi') //440ms
```
