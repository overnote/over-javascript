# 01-内存管理-4-浏览器中 GC 的应用

## 一 垃圾回收概念

程序的运行需要操作系统提供内存支持，比如声明的变量、函数等都需要内存来进行存储。这些从操作系统申请的内存，在无需使用时必须进行释放，否则长时间占用操作系统资源，会引起不必要的性能降低、资源浪费，比如申请的变量已经在函数中使用完毕，其他地方无需使用，这个变量所占据的内存就需要释放！

简单展示 C 语言内存的申请与释放操作：

```c++
#include <stdio.h>
#include <stdlib.h>

int main(){
    // 申请一个数组内存：存储整型数据，元素个数为5
    int *arr = malloc(5 * sizeof(int));

    // 制作数组数据
    for(int i = 0; i < 5; i++){
        arr[i] = i + 1;
    }

    // 打印数据
    for(int i = 0; i < 5; i++){
        printf("arr[%d]=%d\n", i, arr[i]);
    }

    // 释放内存
    free(arr);

    // 此时再打印数据会报错
    return 0;
}
```

从上看出，C 语言是需要手动进行内存管理的，通过 `malloc()` 函数申请内存，通过 `free()` 函数释放内存，这对开发者来说造成了极大的心理负担，尤其在大型复杂项目上，内存的申请与释放更要小心。

因此，一些适合快速开发普通业务的编程语言，如 Java、JavaScript 等语言的引擎内部会对内存进行自动申请、释放，能够有效提升开发效率，对程序中的无效内存进行回收的概念一般称呼为**垃圾回收**，垃圾回收工作依赖于一些复杂的算法，如标记清除、引用计数等，这些统称为：**垃圾回收机制**。

## 一 浏览器垃圾收集机制

### 1.1 标记清除

JavaScript 中最常用的垃圾收集方式是标记清除（ mark-and-sweep）。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。

垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

大多浏览器都会采用标记清楚策略。

### 1.2 引用计数

引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。

引用计数会由于循环依赖问题产生内存泄露：循环引用指的是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的引用。

```js
function problem() {
    var objectA = new Object()
    var objectB = new Object()
    objectA.someOtherObject = objectB
    objectB.anotherObject = objectA
}
```

在采用标记清除策略的实现中，由于函数执行之后，这两个对象都离开了作用域，因此这种相互引用不是个问题。但在采用引用计数策略的实现中，当函数执行完毕后， objectA 和 objectB 还将继续存在，因为它们的引用次数永远不会是 0。假如这个函数被重复多次调用，就会导致大量内存得不到回收。

引用计数策略在浏览器中并未被大量使用，但是 IE 中有一部分对象并不是原生 JavaScript 对象。例如，其 BOM 和 DOM 中的对象就是使用 C++以 COM（ Component Object Model，组件对象模型）对象的形式实现的，而 COM 对象的垃圾收集机制采用的就是引用计数策略。

因此，即使 IE 的 JavaScript 引擎是使用标记清除策略来实现的，但 JavaScript 访问的 COM 对象依然是基于引用计数策略的。换句话说，只要在 IE 中涉及 COM 对象，就会存在循环引用的问题。下面这个简单的例子，展示了使用 COM 对象导致的循环引用问题：

```js
var element = document.getElementById('some_element')
var myObject = new Object()
myObject.element = element
element.someObject = myObject
```

这个例子在一个 DOM 元素（ element）与一个原生 JavaScript 对象（ myObject）之间创建了循环引用。其中，变量 myObject 有一个名为 element 的属性指向 element 对象；而变量 element 也有一个属性名叫 someObject 回指 myObject。由于存在这个循环引用，即使将例子中的 DOM 从页面中移除，它也永远不会被回收。

为了避免类似这样的循环引用问题，最好是在不使用它们的时候手工断开原生 JavaScript 对象与 DOM 元素之间的连接。例如，可以使用下面的代码消除前面例子创建的循环引用:

```js
myObject.element = null
element.someObject = null
```

将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。

当然，IE9 之后微软把 BOM 和 DOM 对象都转换成了真正的 JavaScript 对象。这样，就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄漏现象。

## 二 GC 的性能问题

IE 的垃圾收集器是根据内存分配量运行的，具体一点说就是 256 个变量、 4096 个对象（或数组）字面量和数组元素（ slot）或者 64KB 的字符串。达到上述任何一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本中包含那么多变量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。而这样一来，垃圾收集器就不得不频繁地运行。结果，由此引发的严重性能问题促使 IE7 重写了其垃圾收集例程。

随着 IE7 的发布，其 JavaScript 引擎的垃圾收集例程改变了工作方式：触发垃圾收集的变量分配、字面量和（或）数组元素的临界值被调整为动态修正。 IE7 中的各项临界值在初始时与 IE6 相等。如果垃圾收集例程回收的内存分配量低于 15%，则变量、字面量和（或）数组元素的临界值就会加倍。如果例程回收了 85%的内存分配量，则将各种临界值重置回默认值。这一看似简单的调整，极大地提升了 IE 在运行包含大量 JavaScript 的页面时的性能。

在有的浏览器中可以触发垃圾收集过程，但是不推荐：在 IE 中，调用 window.CollectGarbage()方法会立即执行垃圾收集。

## 三 内存管理

同样是前端应用，与桌面开发相比，分配给 Web 浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行 JavaScript 的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。

因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用（ dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用，如下面这个例子所示：

```js
function createPerson(name) {
    var localPerson = new Object()
    localPerson.name = name

    return localPerson
}

var globalPerson = createPerson('Nicholas')

// 手工解除 globalPerson 的引用
globalPerson = null
```

在这个例子中，变量 globalPerson 取得了 createPerson()函数返回的值。在 createPerson()函数内部，我们创建了一个对象并将其赋给局部变量 localPerson，然后又为该对象添加了一个名为 name 的属性。最后，当调用这个函数时， localPerson 以函数值的形式返回并赋给全局变量 globalPerson。由于 localPerson 在 createPerson()函数执行完毕后就离开了其执行环境，因此无需我们显式地去为它解除引用。但是对于全局变量 globalPerson 而言，则需要我们在不使用它的时候手工为它解除引用，这也正是上面例子中最后一行代码的目的。

不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。
