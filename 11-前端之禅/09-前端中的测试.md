# 09-前端中的测试

## 一 测试定义

### 1.1 常见测试分类

针对小型项目，手动运行查看错误，是最为快捷的方式。但是对一个整合了很多结构、系统的项目来说，手动测试为极大增加排错负担，自动化测试可以在一定程度上减少拍错时间。

一些常见的自动化测试有：编写自动测试脚本、调用应用程序中的函数、对比程序渲染结果等等。自动化测试最大的好处是：检测应用程序是否能够正常工作。

对应用程序执行的正确性进行测试的常见方式有：

-   端到端测试：对整个应用程序及其依赖进行测试
-   单元测试：对程序模块进行测试
-   快照测试：传统的快照测试方式是在浏览器中启动程序后获取其渲染页面的屏幕截图，新截图与旧截图进行比较。

对应用程序的性能进行测试的常见方式有：

-   基准测试：用来统计多少时间内执行了多少次某个方法
-   压力测试：压测一般是对网络接口进行压力测试

### 1.2 测试覆盖率

测试覆盖率是度量自动化测试的指标之一，使用百分比表示，100%代码覆盖率即代表执行测试期间每行代码都会被运行，0%意味着测试时任何一行代码都未被执行。

大多数情况下，100%覆盖率完全没有意义，100%覆盖率会让开发进度变得极度缓慢，获得的收益远不能抵消时间的流式。同样，为前端的组件编写单元测试很重要，但是如果组件的每个属性都编写测试，就会创建一个低效的、减缓开发速度的测试套件。

一个好的组件的单元测试应该始终可以触发一个输入，并断言组件产生正确的输出，要做到这样，应该：从开发者使用组件又不知道组件内部实现的角度编写测试。

组件的输入一般指用户的操作，如：单机按钮。输出一般指 DOM 的变化，如：生成 DOM 节点。
输入：

```txt
组件的props
用户操作
事件
store数据
```

输出：

```txt
发射出去的事件
外部函数引用
```

示例：一个授权组件，接收是否已授权 prop 参数 flag，flag 为 true，则渲染：`已被授权`，否则渲染：`未被授权`。flag 即是输入，渲染的信息即输出。

### 1.3 测试风格

-   TDD（Test Driven Development）：测试驱动开发，关注所有功能是否被正确实现，每一个功能具备对应的测试用例。TDD 的表达方式偏向于功能说明书。倡导先写测试程序，然后编码实现其功能。
-   BDD（Behavior Driven Development）：行为驱动开发，鼓励软件开发中的相关人员进行协作，书写非程序员刻度的测试用例扩展 TDD。关注整体行为是否符合预期，适合自顶向下的设计方式。BDD 的表达方式接近于自然语言。

一些实践：并不一定要严格按照 TDD 等风格来进行开发，比如开发 Vue 组件的顺序：

```txt
1 为每个组件编写单元测试、源码
2 调整组件直到满足需求
3 为已完成组件添加快照测试
4 在浏览器中手动调试
5 编写端到端测试
```

## 二 单元测试

### 2.1 单元测试概念

单元测试（模块测试），用来实现对程序模块的检验。在编写可测试代码时，可以遵循以下原则：

-   单一职责：代码段的职业越多，单元测试就需要构造更多的输入，同时也会影响代码的后期维护
-   接口抽象：通过对程序代码进行接口抽象后，可以针对接口进行测试，而具体代码的变化则不会影响为接口编写的单元测试
-   层次分离：层次分离其实是单一职责原则在项目上的一个整体实现，单元测试应该保证可以逐层测试，逐层保证。

单元测试主要包含：断言、测试框架、测试用例、测试覆盖率、mock 模拟异常、持续集成等几个方面。

### 2.2 测试框架 Mocha

流行的单元测试框架有 Mocha。Mocha 并不是关注测试本身，需要配合 Chai 这样的断言库来编写，Mocha 提供了一套单元测试的输出规范。

```txt
npm i mocha -g
```

mocha 对 TDD 方式的支持：采用 suite 和 test 完成，suite 实现了多层级描述，测试用例使用 test。提供的钩子函数有 setup、teardown，分别表示 suite 前、suit 后执行。

```js
suite('Array', function () {
    setup(function () {
        // ...
    })

    suite('#indexOf()', function () {
        test('should return -1 when not present', function () {
            assert.equal(-1, [1, 2, 3].indexOf(4))
        })
    })
})
```

mocha 对 BDD 方式的支持：主要采用 describe 和 it 进行组织，describe 可以描述多层级结构，具体到测试用例时，可以使用 it。另外内部提供了 before、after、beforeEache、afterEach 这 4 个钩子函数，用于协助 describe 中测试用例的准备、安装、卸载、回收工作。before 和 after 分别在进入和退出 describe 时触发，beforeEach 和 afterEach 分别在 describe 中每一个测试用例（it）执行前、执行后触发。

```js
describe('Array', function () {
    before(function () {
        // ...
    })

    describe('#indexOf()', function () {
        it('should return -1 when not present', function () {})
    })
})
```

mocha 框架与断言之间是解耦的，既可以使用 Node 原生的 assert 模块，也可以使用 should.js、chai 等第三方断言库。

mocha 导出测试报告也支持多种格式，一般使用 json 格式。

mocha 对异步的支持：

```js
it('fs.readFile should be ok', function (done) {
    fs.readFile('file_path', 'utf-8', function (err, data) {
        should.not.exist(err)
        done()
    })
})
```

## 三 测试框架 jest

### 3.1 jest 简介与安装

jest 由 facebook 出品，集成了企业级开发中常用的测试需求工具，是一款简便、强大的综合测试框架。

安装：

### 3.2 TODO

## 四 性能测试

### 4.1 基准测试

基准测试用来统计多少时间内执行了多少次某个方法。假设要测试 ES5 中的 Array.prototype.map 和循环提取值两种方式，他们都是迭代一个数组，根据回调函数执行的返回值得到的一个新的数组，相关代码如下：

```js
var nativeMap = function (arr, callback) {
    return arr.map(callback)
}

var customMap = function (arr, callback) {
    var ret = []
    for (var i = 0; i < arr.length; i++) {
        ret.push(callback(arr[i], i, arr))
    }
    return ret
}
```

比较简单直接的方式就是构造相同的输入数据，然后执行相同的次数，最后比较时间，所以可以写一个方法来执行：

```js
var run = function (name, times, fn, arr, callback) {
    var start = (new Date()).getTime();
    for (var i = 0; i < times; i++) {
        fn(arr, callback);
    }
    var end = (new Date()).getTime();
    console.log('Running s d times cost d ms', name, times, end % % % - start);
};
```

最后分别调用 1000000 次：

```js
var callback = function (item) {
    return item
}
run('nativeMap', 1000000, nativeMap, [0, 1, 2, 3, 5, 6], callback)
run('customMap', 1000000, customMap, [0, 1, 2, 3, 5, 6], callback)
```

由上看出，执行相同的任务，map 耗费的时间大约是直接 for 循环的 5-7 倍以上。

比较好的基准测试框架式 benchmark 第三方模块。

### 4.2 压力测试

基准测试一般是对基本的方法进行测试，压测一般是对网络接口进行压力测试。压测需要考察的指标有：吞吐率、响应时间、并发数。

常用的压测工具有：ab、http_load，使用 ab 工具如下：

```txt
# 10个并发用户持续3秒向服务端发送请求
ab -c 10 -t 3 http://localhost:8001/
```
