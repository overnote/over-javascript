# 15.1-设计原则总结

## 零 设计原则概览

每种设计模式都是为了让代码迎合其中一个或多个原则而出现的，设计原则本身已经融入了设计模式之中。常见的设计原则有：

- 单一职责原则
- 里氏替换原则
- 依赖倒置原则
- 接口隔离原则
- 合成复用原则
- 最少知识原则

## 一 单一职责原则

### 1.1 单一职责原则概念

就一个对象而言，应该仅有一个引起它变化的原因。

单一职责原则（SRP）的职责被定义为“引起变化的原因”。如果我们有两个动机去改写一个方法，那么这个方法就具有两个职责。每个职责都是变化的一个轴线，如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。此时，这个方法通常是一个不稳定的方法，修改代码总是一件危险的事情，特别是当两个职
责耦合在一起的时候，一个职责发生变化可能会影响到其他职责的实现，造成意想不到的破坏，这种耦合性得到的是低内聚和脆弱的设计。

因此，SRP 原则体现为：一个对象（方法）只做一件事情。

### 1.2 何时应该分离职责

并不是所有的职责都应该一一分离。

一方面，如果随着需求的变化，有两个职责总是同时变化，那就不必分离他们。比如在 ajax 请求的时候，创建 xhr 对象和发送 xhr 请求几乎总是在一起的，那么创建 xhr 对象的职责和发送 xhr 请求的职责就没有必要分开。

另一方面，职责的变化轴线仅当它们确定会发生变化时才具有意义，即使两个职责已经被耦合在一起，但它们还没有发生改变的征兆，那么也许没有必要主动分离它们，在代码需要重构的时候再进行分离也不迟。

### 1.3 违反 SRP 原则

在人的常规思维中，总是习惯性地把一组相关的行为放到一起，如何正确地分离职责不是一件容易的事情。

一方面，我们受设计原则的指导，另一方面，我们未必要在任何时候都一成不变地遵守原则。在实际开发中，因为种种原因违反 SRP 的情况并不少见。比如 jQuery 的 attr 等方法，就是明显违反 SRP 原则的做法。jQuery 的 attr 是个非常庞大的方法，既负责赋值，又负责取值，这对于 jQuery 的维护者来说，会带来一些困难，但对于 jQuery 的用户来说，却简化了用户的使用。

在方便性与稳定性之间要有一些取舍。具体是选择方便性还是稳定性，并没有标准答案，而是要取决于具体的应用环境。

### 1.4 SRP 原则优缺点

优点：降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度，这有助于代码的复用，也有利于进行单元测试。当一个职责需要变更的时候，不会影响到其他的职责。

缺点：会增加编写代码的复杂度。当我们按照职责把对象分解成更小的粒度之后，实际上也增大了这些对象之间相互联系的难度。

## 二 开放-封闭原则

### 2.1 开放-封闭原则概念

开放-封闭原则（OCP）：软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改。其思想是：当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码。

软件实体是一个广义的概念，不仅包括对象，还包括系统、类、模块、函数、变量等。

几乎所有的设计模式都是遵守开放  封闭原则的，我们见到的好设计，通常都经得起开放-封闭原则的考验。

### 2.2 开放-封闭原则示例

假设 window.onload 方法已经有了几百行，而现在要加入 log 功能，通过增加代码，而不是修改代码的方式，来给 window.onload 函数添加新的功能：

```js
Function.prototype.after = function (afterfn) {
  const __self = this
  return function () {
    const ret = __self.apply(this, arguments)
    afterfn.apply(this, arguments)
    return ret
  }
}

window.onload = (window.onload || function () {}).after(function () {
  console.log(document.getElementsByTagName('*').length)
})
```

### 2.3 用对象的多态性消除条件分支

下面先提供一段不符合开放-封闭原则的代码。每当我们增加一种新的动物时，都需要改动 makeSound 函数的内部实现：

```js
class Duck {}
class Chicken {}

const makeSound = function (animal) {
  if (animal instanceof Duck) {
    console.log('嘎嘎嘎')
  } else if (animal instanceof Chicken) {
    console.log('咯咯咯')
  }
}

makeSound(new Duck()) // 输出：嘎嘎嘎
makeSound(new Chicken()) // 输出：咯咯咯
```

动物世界里增加一只狗之后，makeSound 函数就必须再加一次 if 判断。利用多态的思想，我们把程序中不变的部分隔离出来（动物都会叫），然后把可变的部分封
装起来（不同类型的动物发出不同的叫声），这样一来程序就具有了可扩展性。当我们想让一只狗发出叫声时，只需增加一段代码即可，而不用去改动原有的 makeSound 函数：

```js
class Duck {
  sound() {
    console.log('嘎嘎嘎')
  }
}
class Chicken {
  sound() {
    console.log('咯咯咯')
  }
}
class Dog {
  sound() {
    console.log('汪汪汪')
  }
}

const makeSound = function (animal) {
  animal.sound()
}

makeSound(new Duck()) // 嘎嘎嘎
makeSound(new Chicken()) // 咯咯咯
makeSound(new Dog()) // 汪汪汪
```

遵循开放-封闭原则的经典办法是：是找出程序中将要发生变化的地方，然后把变化封装起来。

由于每种动物的叫声都不同，所以动物具体怎么叫是可变的，于是我们把动物具体怎么叫的逻辑从 makeSound 函数中分离出来。而动物都会叫这是不变的，makeSound 函数里的实现逻辑只跟动物都会叫有关，这样一来，makeSound 就成了一个稳定和封闭的函数。

### 2.4 放置挂钩

放置挂钩（hook）也是分离变化的一种方式。我们在程序有可能发生变化的地方放置一个挂钩，挂钩的返回结果决定了程序的下一步走向。这样一来，原本的代码执行路径上就出现了一个分叉路口，程序未来的执行方向被预埋下多种可能性。

jQuery 从 1.4 版本开始，陆续加入了 fixHooks、kmouseHooks、cssHooks 等挂钩。Template Method 模式中的父类是一个相当稳定的类，它封装了子类的算法骨架和执行步骤。

由于子类的数量是无限制的，总会有一些“个性化”的子类迫使我们不得不去改变已经封装好的算法骨架。于是我们可以在父类中的某个容易变化的地方放置挂钩，挂钩的返回结果由具体子类决定。这样一来，程序就拥有了变化的可能。

在 JavaScript 中，函数可以作为参数传递给另外一个函数，这是高阶函数的意义之一。在这种情况下，我们通常会把这个函数称为回调函数。在 JavaScript 版本的设计模式中，策略模式和命令模式等都可以用回调函数轻松实现。

回调函数是一种特殊的挂钩。我们可以把一部分易于变化的逻辑封装在回调函数里，然后把回调函数当作参数传入一个稳定和封闭的函数中。当回调函数被执行的时候，程序就可以因为回调函数的内部逻辑不同，而产生不同的结果。

我们通过 ajax 异步请求用户信息之后要做一些事情，请求用户信息的过程是不变的，而获取到用户信息之后要做什么事情，则是可能变化的：

```js
const getUserInfo = function (callback) {
  $.ajax('http:// xxx.com/getUserInfo', callback)
}
getUserInfo(function (data) {
  console.log(data.userName)
})
getUserInfo(function (data) {
  console.log(data.userId)
})
```

### 2.5 思考

让程序保持完全封闭是不容易做到的。就算技术上做得到，也需要花费太多的时间和精力。而且让程序符合开放-封闭原则的代价是引入更多的抽象层次，更多的抽象有可能会增大代码的复杂度。

有一些代码是无论如何也不能完全封闭的，总会存在一些无法对其封闭的变化，只要做到以下即可：

- 挑选出最容易发生变化的地方，然后构造抽象来封闭这些变化。
- 在不可避免发生修改的时候，尽量修改那些相对容易修改的地方。拿一个开源库来说，修改它提供的配置文件，总比修改它的源代码来得简单

## 三 最少知识原则

### 3.1 最少知识原则概念

最少知识原则（LKP,迪米特法则）说的是一个软件实体应当尽可能少地与其他实体发生相互作用。

单一职责原则指导我们把对象划分成较小的粒度，这可以提高对象的可复用性。但越来越多的对象之间可能会产生错综复杂的联系，如果修改了其中一个对象，很可能会影响到跟它相互引用的其他对象。对象和对象耦合在一起，有可能会降低它们的可复用性。

最少知识原则要求我们在设计程序时，应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的相互联系。常见的做法是引入一个第三者对象，来承担这些对象之间的通信作用。如果一些对象需要向另一些对象发起请求，可以通过第三者对象来转发这些请求。

最少知识原则在设计模式中体现得最多的地方是中介者模式和外观模式。

中介者模式很好地体现了最少知识原则。通过增加一个中介者对象，让所有的相关对象都通过中介者对象来通信，而不是互相引用。所以，当一个对象发生改变时，只需要通知中介者对象即可。
