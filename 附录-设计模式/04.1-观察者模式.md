# 03.1-观察者模式

## 一 观察者模式概念

观察者模式，也即发布订阅模式。

小明最近看上了一套房子，到了售楼处之后才被告知，该楼盘的房子早已售罄。好在售楼 MM 告诉小明，不久后还有一些尾盘推出，开发商正在办理相关手续，手续办好后便可以购买。小明离开之前，把电话号码留在了售楼处。售楼 MM 答应他，新楼盘一推出就马上发信息通知小明。小红、小强和小龙也是一样，他们的电话号码都被记在售楼处的花名册上，新楼盘推出的时候，售楼 MM 会翻开花名册，遍历上面的电话号码，依次发送一条短信来通知他们。

小明、小红等购买者都是订阅者，他们订阅了房子开售的消息。售楼处作为发布者，会在合适的时候遍历花名册上的电话号码，依次给购房者发布消息。

可以发现，在这个例子中使用发布—订阅模式有着显而易见的优点：

- 购房者不用再天天给售楼处打电话咨询开售时间，在合适的时间点，售楼处作为发布者会通知这些消息订阅者。
- 购房者和售楼处之间不再强耦合在一起，当有新的购房者出现时，他只需把手机号码留在售楼处，售楼处不关心购房者的任何情况，不管购房者是男是女还是一只猴子。 而售楼处的任何变动也不会影响购买者，比如售楼 MM 离职，售楼处从一楼搬到二楼，这些改变都跟购房者无关，只要售楼处记得发短信这件事情。

第一点说明发布—订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。比如，我们可以订阅 ajax 请求的 error、succ 等事件。或者如果想在动画的每一帧完成之后做一些事情，那我们可以订阅一个事件，然后在动画的每一帧完成之后发布这个事件。在异步编程中使用发布—订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。

第二点说明发布—订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。发布—订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。

## 二 观察者模式实现

### 2.1 观察者模式基本实现

实现一个发布订阅模式，需要以下步骤：

- 首先要指定好谁充当发布者（比如售楼处）；
- 然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者（售楼处的花名册）；
- 最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数（遍历花名册，挨个发短信）。

```js
// 发布者
class Publisher {
  events = [] // 缓存事件列表：存放订阅者回调函数

  // 订阅消息：即增加订阅者
  sub(cb) {
    this.events.push(cb)
  }

  // 发布消息
  pub() {
    this.events.map((item) => {
      item.apply(this, arguments) // arguments 是发布消息时带上的参数
    })
  }
}

// 测试
const p = new Publisher()
// 小明订阅消息
p.sub((price, squareMeter) => {
  console.log(squareMeter, '平', price, '万')
})
// 小红订阅消息
p.sub((price, squareMeter) => {
  console.log(squareMeter, '平', price, '万')
})
// 发布消息
p.pub(200, 88)
p.pub(300, 110)
```

上述基础的发布订阅模式有个问题：我们看到订阅者接收到了发布者发布的每个消息，虽然小明只想买 88 平方米的房子，但是发布者把 110 平方米的信息也推送给了小明，这对小明来说是不必要的困扰。所以我们有必要增加一个标示 key，让订阅者只订阅自己感兴趣的消息。此外还需要取消订阅：

```js
// 发布者
class Publisher {
  events = {} // 缓存事件列表：存放订阅者回调函数

  // 订阅消息：即增加订阅者
  sub(key, cb) {
    if (!this.events[key]) {
      this.events[key] = []
    }
    this.events[key].push(cb)
  }

  // 发布消息
  pub() {
    // 取出消息类型
    const key = Array.prototype.shift.call(arguments)
    const cbList = this.events[key]
    if (!cbList || cbList.length <= 0) {
      return false
    }

    cbList.map((item) => {
      item.apply(this, arguments) // arguments 是发布消息时带上的参数
    })
  }

  // 取消订阅
  remove(key, cb) {
    const cbList = this.events[key]
    if (!cbList) {
      // 如果 key 对应的消息没有被人订阅，则直接返回
      return false
    }
    if (!cb) {
      // 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅
      cbList && (cbList.length = 0)
      return
    }

    for (let l = cbList.length - 1; l >= 0; l--) {
      // 反向遍历订阅的回调函数列表
      var _fn = cbList[l]
      if (_fn === cb) {
        cbList.splice(l, 1) // 删除订阅者的回调函数
      }
    }
  }
}

// 测试
const p = new Publisher()
// 小明订阅 100平
p.sub('200', (price) => {
  console.log('200平', price, '万')
})
// 小红订阅 300平
p.sub('300', (price) => {
  console.log('300平', price, '万')
})
// 发布消息
p.pub(200, 88)
p.pub(300, 110)
```

## 三 观察者模式应用

### 3.1 DOM 事件

DOM 操作是一个经典发布订阅模式：

```js
document.body.addEventListener(
  'click',
  () => {
    alert(2)
  },
  false
)
document.body.click() // 模拟用户点击
```

在这里需要监控用户点击 document.body 的动作，但是我们没办法预知用户将在什么时候点击。所以我们订阅 document.body 上的 click 事件，当 body 节点被点击时，body 节点便会向订阅者发布这个消息。这很像购房的例子，购房者不知道房子什么时候开售，于是他在订阅消息后等待售楼处发布消息。
