# 03.1-组件基础-组件注册

## 一 Vue 组件创建化开发思想

### 1.1 组件化思想

组件化是指从 UI 界面角度出发，合理重用 UI 组件。如果将一个页面中的业务逻辑放在一起，将会让项目变得难以维护、扩展，将页面拆分为一个个小的功能块，每个功能块具有完全独立的功能，不同功能块之间通过一些方法进行关联，这样更便于扩展、维护。

具体的实现细则：

```txt
将一个完整的页面拆分为多个功能块组件，每个组件用于实现页面的一个功能块
每个组件内部可以进一步进行划分为更加细小的组件
```

组件化为页面的开发实现了更好的抽象，达到复用效果，任何应用都可以被抽象为一棵组件树：

![组价树](../images/mvvm/vue-02.png)

### 1.2 单文件组件

在代码中直接使用方法等方式定义组件并不适合大型项目，且 ES6 的语法在很多浏览器中不被支持。在企业级开发中，Vue 推荐使用一种类似 HTML 格式的文件来书写 Vue 组件，它被称为单文件组件 ( Single-File Components，缩写为 SFC)。即：Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里，这些组件化文件以 `.vue` 后缀为结尾，并通过编译、打包工具来进行线上环境部署。

如下所示一个完整的组件示例：

```html
<template>
  <div class="hello">
    <h1>{{ msg }}</h1>
  </div>
</template>

<script>
  export default {
    name: 'HelloWorld',
  }
</script>

<style scoped lang="scss">
  h1 {
    margin: 40px 0 0;
  }
</style>
```

该 vue 文件可以被导出，多次重复利用，也可以在引入使用后绑定事件等等。Vue SFC 是一个框架指定的文件格式，因此必须交由 @vue/compiler-sfc 编译为标准的 JavaScript 和 CSS，一个编译后的 SFC 是一个标准的 JavaScript(ES) 模块，这也意味着在构建配置正确的前提下，你可以像导入其他 ES 模块一样导入 SFC：

```js
import MyComponent from './MyComponent.vue'

export default {
  components: {
    MyComponent,
  },
}
```

SFC 中的 `<style>` 标签一般会在开发时注入成原生的 `<style>` 标签以支持热更新，而生产环境下它们会被抽取、合并成单独的 CSS 文件。在实际项目中，我们一般会使用集成了 SFC 编译器的构建工具，比如 Vite 或者 Vue CLI (基于 webpack)。

**Volar VSCode** 插件为 Vue SFC 提供了开箱即用的格式化功能。除此之外，Prettier 也提供了内置的 Vue SFC 格式化支持。

基于此，一些有着传统 Web 开发背景的用户可能会因为 SFC 将不同的关注点集合在一处而有所顾虑，觉得 HTML/CSS/JS 应当是分离开的！

要回答这个问题，我们必须对这一点达成共识：前端开发的关注点不是完全基于文件类型分离的。前端工程化的最终目的都是为了能够更好地维护代码。关注点分离不应该是教条式地将其视为文件类型的区别和分离，仅仅这样并不够帮我们在日益复杂的前端应用的背景下提高开发效率。

在现代的 UI 开发中，我们发现与其将代码库划分为三个巨大的层，相互交织在一起，不如将它们划分为松散耦合的组件，再按需组合起来。在一个组件中，其模板、逻辑和样式本就是有内在联系的、是耦合的，将它们放在一起，实际上使组件更有内聚性和可维护性。

即使你不喜欢单文件组件这样的形式而仍然选择拆分单独的 JavaScript 和 CSS 文件，也没关系，你还是可以通过资源导入功能获得热更新和预编译等功能的支持。

## 二 注册组件

### 2.0 组件注册概念

一个 .vue 后缀的单文件组件在引入后，不能直接被使用，使用前需要先被 ”注册“，这样 Vue 才能在渲染模板时找到其对应的实现。

组件注册有两种方式：全局注册和局部注册。局部注册使用较多。

### 2.1 局部注册

局部组件是挂载在了 Vue 的实例上，而且只能在注册他的父组件中使用！

```js
import ComponentA from './ComponentA.js'

export default {
  components: {
    ComponentA,
  },
  setup() {
    // ...
  },
}
```

对于每个 components 对象里的属性，它们的 key 名就是注册的组件名，而值就是相应组件的实现。上面的例子中使用的是 ES2015 的缩写语法，等价于：

```js
export default {
  components: {
    ComponentA: ComponentA,
  },
  // ...
}
```

注意：**在使用 `<script setup>` 的单文件组件中，导入的组件可以直接在模板中使用，无需注册**。

### 2.2 全局注册

全局注册的组件可以在此应用的任意组件的模板中使用。使用 Vue 应用实例的 app.component() 方法，让组件在当前 Vue 应用中全局可用：

```js
const app = createApp({})

app.component(
  // 注册的名字
  'MyComponent',
  // 组件的实现
  {
    /* ... */
  }
)
```

如果是单文件组件，可以注册被导入的 .vue 文件：

```js
import MyComponent from './App.vue'

app.component('MyComponent', MyComponent)
```

### 2.3 全局注册于局部注册对比

全局注册虽然很方便，但有以下几个问题：

- 全局注册，但并没有被使用的组件无法在生产打包时被自动移除 (也叫“tree-shaking”)。如果你全局注册了一个组件，即使它并没有被实际使用，它仍然会出现在打包后的 JS 文件中。
- 全局注册在大型项目中使项目的依赖关系变得不那么明确。在父组件中使用子组件时，不太容易定位子组件的实现。和使用过多的全局变量一样，这可能会影响应用长期的可维护性。

相比之下，局部注册的组件需要在使用它的父组件中显式导入，并且只能在该父组件中使用。它的优点是使组件之间的依赖关系更加明确，并且对 tree-shaking 更加友好。

## 三 组件注册的注意事项

### 3.1 常见重要注意点

Vue2.x 中组件的根元素只能有一个，Vue3 则无需注意。

### 3.2 组件命名格式

组件命名时：若没有使用驼峰式命名，则该名称可以直接使用；若使用了驼峰命名，在引用组件的时候，需要把大写的驼峰改为小写的字母，同时两个单词之间使用 `-` 连接。

### 3.3 组件的 data 属性

组件是一个单独的功能模块的封装，所以不能直接访问 Vue 实例的数据对象 data，组件自己的数据应该由自己存储，即组件自身的 data 函数。

**组件的 data 属性必须是一个函数，且返回一个对象。**

因为：函数能够形成独立的作用域环境，避免污染。如：某个组件在界面中使用了多次，这些组件之间内部的数据是不应该共用一个 data 对象的，而是每次在界面中使用了该组件，就应该创建一个全新的数据对象，所以只能是函数形式，在函数内部返回一个数据对象。

### 3.4 引用 template

template 属性也可以直接引用其他已经定义好的 template。

```html
<div id="app">
  <my-com3></my-com3>
</div>

<template id="tmp1">
  <h3>组件</h3>
</template>

<script>
  Vue.component('myCom3', {
    template: '#tmp1',
  })

  new Vue({
    el: '#app',
  })
</script>
```

## 四 动态组件

### 4.1 动态组件实现组件切换

除了可以使用自定义 true/false 方式来切换组件外，vue 本身也提供了组件切换机制：在 component 里展示对应名称的组件

```html
<div id="app">
  <span @click="who='com1'">显示组件 1</span>
  <span @click="who='com2'">显示组件 2</span>
  <component :is="who"></component>
</div>

<script>
  Vue.component('com1', {
    template: '<h3>111</h3>',
  })

  Vue.component('com2', {
    template: '<h3>222</h3>',
  })

  let vm = new Vue({
    el: '#app',
    data: {
      who: 'com1',
    },
  })
</script>
```
