# 09-加密-1-密码学

## 一 密码学概述

### 1.1 加密算法分类

常用的加密算法有三类：

- 哈希算法：不可逆
- 加密解密算法：通过秘钥实现加密解密，是可逆的
- 编码解码算法：无需秘钥，是可逆的，如 Base64，但是严格意义上来说该类算法只是一种数据编码格式，而非加密

### 1.2 哈希算法

> 哈希算法：让任意长度的数据通过该算法映射为较短的固定长度的数据，并且不同数据基本上不会映射为相同的 Hash 值。

哈希算法其实是一种消息摘要实现技术，hash 是剁碎的意思，所以也称呼 hash 为散列，其加密是不可逆的，常见的 hash 算法有：

```txt
md4、md5、hash1、SHA256、SHA3
```

哈希算法加密不可逆，常见的算法有： 等。

例如一段字符串`hello world`，经过 md5 加密后转换成了：`5eb63bbbe01eeed093cb22bb8f5acdc3`，该密文是无法返回到原始的明文的。但是现在一些网站能够根据结构给出原始值，是因为其数据库存暴力存储了一些常用数据经过哈希后得到的结果。

哈希算法必须解决冲突问题，即不同的数据通过哈希算法产生了相同的输出，MD5，SHA-1 算法都已经被证明不具备`强抗碰撞性`，不足以应对要求很高的商业场景。为了提升哈希算法的安全性，推荐使用 SHA-2，该算法是 SHA-256,SHA-512 等算法的并称。

不过 MD5 仍然被大量用于网站的登录中，如下所示：

![登录设计](../../images/node/04-01.png)

彩虹表攻击会让哈希算法变得很脆弱，通过加盐的方式能够提升安全性：

![加盐](../../images/node/04-02.png)

### 1.3 加解密算法

加密解密算法包括三种：

- 对称加密：包括 DES、3DES、AES 等
- 非对称加密：包括 RSA 算法、椭圆曲线加密算法
- 数字签名算法 DSA

### 1.4 编码解码算法

编码解码算法常见的有 Base64 编码解码，Base58 编码解码。

## 二 对称加密

对称加密（datar encryption algorithm，DEA）也称为私钥加密算法、单秘钥算法。对称加密的特点：

- 加密和解密的秘钥相同
- 运算效率加高

使用图示：

![对称加密](../../images/node/04-03.png)

DES 目前是非常安全的加密方式，只有穷举法才可以破解。常见的对称加密算法有：DES,3DES,AES 等。

对称加密由于加密方和解密方双方使用同一个秘钥，所以必须保证该秘钥的绝对安全性！此外，每对用户每次使用加密算法时，都需要使用其他人不知道的唯一钥匙，这样收发双方拥有的钥匙数量会呈几何增长，故而不适合分布式系统（不过分布式系统本身就应该是无状态的）。

## 三 非对称加密

### 3.1 非对称加密概念

非对称加密也称呼为公钥加密，最著名的非对称加密算法是 RSA、椭圆曲线算法 ECC。

非对称加密的特点：加密和解密分别使用两个不同的秘钥。使用其中一个秘钥对明文加密得到的密文，只有另外一个秘钥才能解密得到明文！而且这 2 个秘钥只在数学上有关，即使知道了其中一个，也无法计算出另外一个，所以一个可以公开，任意发布，一个不公开，由用户保管，绝对不同通过任何途径传输。

这两个秘钥分别是：

- 公钥：公开秘钥，公钥可以向外任意发布。
- 私钥：私有秘钥，私钥由用户存储，私钥不能通过任何渠道传输

总结如下：

- 公开密钥和私有密钥是一对
- 如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密。
- 如果用私有密钥对数据进行加密，只有用对应的公开密钥才能解密。
- 因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。

步骤如下：
![非对称加密](../../images/node/04-04.png)

非对称加密中用于解密的私钥是不公开、不进行传输的，所以安全性较高，但是相对的，也增加了运算时间。

### 3.2 数字签名与验证

非对称加密中双方进行通信的加密解密过程：

- 1.A 要向 B 发送信息，A 和 B 都要产生一对用于加密和解密的公钥和私钥
- 2.A 的私钥保密，A 的公钥告诉 B；B 的私钥保密，B 的公钥告诉 A。
- 3.A 要给 B 发送信息时，A 用 B 的公钥加密信息，因为 A 知道 B 的公钥。
- 4.A 将这个消息发给 B（已经用 B 的公钥加密消息）。
- 5.B 收到这个消息后，B 用自己的私钥解密 A 的消息。其他所有收到这个报文的人都无法解密，因为只有 B 才有 B 的私钥。

通过公钥加密、私钥解密的过程，称为数字签名、验证签名。数字签名有两部分组成：

- 使用私钥从消息中创建签名
- 允许任何人验证签名

数字签名主要用于验证双方的数据是否被串改，数字签名与加密解密不是一个概念！

非对称加密找那个双方进行通信时，不但要对消息进行加密解密，也要执行数字签名与验证：

![数字签名](../../images/node/04-05.png)

## 四 网络的安全传输

### 4.1 SSL 简介

传统的网络传输中，内容都是以明文形式传输，安全性很低。而对于 HTTP、FTP 协议而言，我们同样希望其本身只是负责数据的传输而不是加密解密。SSL 是当年的网景公司（火狐的前身）退出的安全协议，它会在传输层提供对网络连接的加密功能。对于应用程序而言，数据在传递到应用层之前就已经完成了加密、解密的过程。SSL 经过标准化后，称呼为 TLS。

HTTPS 即 SSL 和 HTTP 结合产物，WSS 即 SSL 和 WebSocket 结合的产物。

当然 HTTPS 由于引入了加密解密过程，而且这种加密机制使用的是非对称加密，其算法性能很低，所以 HTTPS 也因此牺牲了很大一部分性能。

### 4.2 SSL 实现

不同的 SSL 握手过程存在差异，分为以下三种：

- 只验证服务器
- 验证服务器和客户端
- 恢复原有会话

这里只介绍第一种过程。

**第 1 步**：客户端发送一个消息，假为 Client Hello，给服务端，该消息包括：

```txt
一个随机数（假设它是random1）
一个session id(用来避免后续请求的握手)
浏览器支持的密码套件（cipher suite），即由加密算法名称组成的字符串，示例：TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
```

**第 2 步**：服务器对消息进行验证（如 SSL 版本）后，返回一个消息给客户端，假设为 Server Hello，该消息包括：

```txt
服务器支持的 SSL 版本信息
一个伪随机数（假设它是 random2）
服务器的密码套件（cipher suite）
```

**第 3 步**：服务器发送 CA 证书给客户端

**第 4 步**：服务器发送 Server Hello done

**第 5 步**：客户端验证服务器证书的合法性后(Certificate Verify)后，利用证书中的公钥加密 premaster secret(一个在堆成加密密钥生成中的 46 字节随机数字，以及消息认证代码)作为 Client Key Exchange 的消息发送给服务器。

**第 6 步**：SSL 客户端发送 Change Cipher Spec 消息，该消息属于 SSL 密码变化协议

**第 7 步**：客户端计算历史消息的 hash 值，然后使用服务器公钥加密后发送给服务器，服务器进行同样的操作，然后两个值结果相同表示密钥交换成功

**第 8 步**：服务器发送 Change Cipher Spec 消息

**第 9 步**：服务器计算历史消息的 hash 值，通过交换后的密钥加密，将其作为 finished 消息发送给客户端，客户端利用交换后的密钥解密，如果和本地历史消息相同就黄泽宁服务器身份，握手结束

### 4.3 密钥交换步骤

常见的密钥交换算法是 RSA 算法，是一种非对称加密算法，步骤如下：

- 步骤 1：Client Verify。客户端接收到服务端传来的整数后，先验证该证书合法性，验证通过后取出证书中的服务端公钥，再生成一个随机数 random3，再用服务端公钥加密 random3 生成 PreMasterKey
- 步骤 2：Clent Key Exchange：将第一步最后生成的 key 传给服务端，服务端用自己的私钥解出这个 key，得到客户端生成的 random3，再加上 random1，random2，至此，客户端和服务端都拥有了 random1，random2，random3.

两边再根据同样的算法就可以生成一份密钥，握手结束后应用层数据都是用该密钥进行对称加密，使用三个随机数的原因是提升暴力破解难度。

### 4.4 CA 证书与中间人攻击

上述的步骤就像两个同学上课传纸条，二人为了不让其他人发现纸条的信息，互相约定了写法和破译，各自的加密内容只有自己的解密办法才能破译，那么在传输信息前需要双方交换自己的加方法（公钥）。

然而在第一次交换加密方法的纸条传递时，中间负责传递的同学把交换双方的公钥都换成了自己伪造的公钥，那么就可以轻松使用自己的私钥读取她们的通信内容，这就是中间人攻击。

CA 是第三方组织，用来验证证书合法性，即在上述案例中，纸条由互相信任的班主任传递。

## 五 创建证书

制作公钥与私钥：

```txt
# 生成服务端私钥
openssl genrsa -out server.key 1024

# 生成服务端公钥
openssl rsa -in server.key -pubout -out server.pem

# 生成客户端私钥
openssl genrsa -out client.key 1024

# 生成客户端公钥
openssl rsa -in client.key -pubout -out client.pem
```

公钥和私钥仍然不能完全预防破解、窃听的可能，典型的例子是中间人攻击。客户端和服务端在交换公钥的过程中，中间人对客户端扮演服务端角色，对服务端扮演客户端角色，客户端和服务端就不再感受到有中间人的存在。为了解决这个问题，数据传输还需要对得到的公钥进行认证，以确认得到的公钥是出自目标服务器！这便是数字认证，一般使用第三方数字证书颁发机构 CA 制作的证书，这个证书中具有 CA 通过自己的刚要和私钥实现的签名。

为了得到签名证书，服务端需要通过自己的私钥生成 CSR 证书签名请求文件，CA 机构通过该文件办法属于该服务端的签名证书，只要通过 CA 机构就能验证证书是否合法。

通过 CA 机构办法证书相当复杂耗时，中小企业一般采用自签名来构建安全网络，就是自己扮演 CA 机构，给自己的服务端办法签名证书，下面步骤即是制作扮演 CA 角色需要的文件：

```txt
openssl genrsa -out ca.key 1024
openssl req -new -key ca.key -out ca.csr
openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt
```

服务端此时需要向 CA 机构申请签名证书，在申请前要创建自己的 CSR 文件（Common Name 要匹配服务器域名）：

```txt
openssl req -new -key server.key -out server.csr
```

得到 CSR 文件后，向自己的 CA 机构申请签名：

```txt
openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in server.csr -out server.crt
```

客户端在发起安全连接前先回去获取服务端的证书，通过 CA 的证书验证服务端证书、服务器名称、服务器 IP 的真伪。

CA 机构将证书颁发给服务端后，证书在请求过程中会被发送给客户端，客户端需要通过 CA 的证书验证真伪，如果是知名的 CA 机构，它们的证书一般会预装在浏览器中，如果是自己扮演的 CA 机构，颁发自有签名则没有该福利！！

注意：签名证书是一环一环的颁发的，但是在 CA 那里的证书是不需要上级证书参与签名的，这个证书通常称为根证书。
