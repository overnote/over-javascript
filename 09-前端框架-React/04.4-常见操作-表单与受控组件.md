# 04.4-常见操作-表单与受控组件

## 一 受控组件

在 HTML 中，表单元素（如`<input>`、 `<textarea>` 和 `<select>`）通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新。我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。

在受控组件中，输入的值始终由 React 的 state 驱动，组件渲染出的状态与它的 value 或 checked prop 相对应。React 通过这种方式消除了组件的局部状态，使得应用的整个状态更加可控。例如，如果我们想让前一个示例在提交时打印出名称，我们可以将表单写为受控组件：

```js
function Demo() {
  const [value, setValue] = useState('')
  const handleChange = (e) => {
    setValue(e.target.value)
  }
  const handleSubmit = (e) => {
    console.log('提交的名字: ', value)
    e.preventDefault()
  }

  return (
    <form onSubmit={handleSubmit}>
      <label>
        名字:
        <input type="text" value={value} onChange={handleChange} />
      </label>
      <input type="submit" value="提交" />
    </form>
  )
}
```

总结下 React 受控组件更新 state 的流程：

- (1) 可以通过在初始 state 中设置表单的默认值。
- (2) 每当表单的值发生变化时，调用 onChange 事件处理器。
- (3) 事件处理器通过合成事件对象 e 拿到改变后的状态，并更新应用的 state。
- (4) setState 触发视图的重新渲染，完成表单组件值的更新

在 React 中，数据是单向流动的。一般通过 props 传递给组件的 state，现在又通过 onChange 事件处理器将新的表单数据写回到组件的 state，完成了双向数据绑定。

## 二 常见表单元素操作

### 2.1 textarea 标签

textarea 与 上述 input 案例 使用相似，也使用 value 属性代替，这里不做赘述。

### 2.2 select 标签

React 并不会使用 selected 属性，而是在根 select 标签上使用 value 属性。这样这在受控组件中使用起来更方便：

```html
<select value="{value}" onChange="{handleChange}">
  <option value="grapefruit">葡萄柚</option>
  <option value="lime">酸橙</option>
  <option value="coconut">椰子</option>
  <option value="mango">芒果</option>
</select>
```

### 2.3 input 操作文件

当 `<input type="file">` 时，value 是只读的，此时是一个非受控组件，见非搜空组件相关章节。

### 2.4 处理多个 input 输入

当需要处理多个 input 元素时，我们可以给每个元素添加 name 属性，并让处理函数根据 event.target.name 的值选择要执行的操作。

```js
function Demo() {
  const [value, setValue] = useState({
    sex: false,
    age: 0,
  })

  const handleChange = (e) => {
    const target = e.target
    const value = target.type === 'checkbox' ? target.checked : target.value
    const name = target.name

    console.log('change..')

    setValue({
      ...value,
      [name]: value,
    })
  }

  return (
    <form>
      <label>
        性别:
        <input
          type="checkbox"
          name="sex"
          value={value.sex || false}
          onChange={handleChange}
        />
      </label>
      <br />
      <label>
        年龄:
        <input
          type="text"
          name="age"
          value={value.age || 0}
          onChange={handleChange}
        />
      </label>
    </form>
  )
}
```

贴士：示例中，jsx 的输入框都给了默认的 value，`|| false` 、 `|| 0`，如果不这样做，由于默认初始值都是 undefined，输入框会被作为非受控组件处理。

## 三 受控组件输入中文 BUG

受控组件使用 onChange 时，经常会出现中文未输入完就触发了 onChange 事件，这是因为 input 输入框其实还有三个事件未做处理：

```js
class Demo extends React.Component {
  constructor(props) {
    super(props)
  }

  compositionstart(event) {
    console.log('开始输入', event.data)
  }

  compositionupdate(event) {
    document.getElementById('data').innerHTML = event.data
    console.log('正在输入的数据', event.data)
  }

  compositionend(event) {
    console.log('结束输入', event.data)
  }

  changeEvent() {
    console.log('改变')
  }

  render() {
    return (
      <div>
        <input
          type="text"
          id="test"
          onChange={this.changeEvent.bind(this)}
          onCompositionStart={this.compositionstart.bind(this)}
          onCompositionUpdate={this.compositionupdate.bind(this)}
          onCompositionEnd={this.compositionend.bind(this)}
        />
        输入的数据为 <span id="data"></span>
      </div>
    )
  }
}
```

定义一个中间变量 isOncomposition，默认为 true，当触发 compositionend 事件时，我们把它赋为 false，这样 change 事件就会执行，但是在 Chrome 浏览器中，compositionend 事件是后于 change 事件触发的，所以还要考虑该情况：

```js
let isOnComposition = false;
const isChrome = !!window.chrome && !!window.chrome.webstore

class App extends React.Component {

	handleComposition(e) {
		if (e.type === 'compositionend') {
			// composition is end
			isOnComposition = false

			if (!isOnComposition && isChrome) {
				// fire onChange
				this.changeEvent(e);
			}
		} else {
			// in composition
			isOnComposition = true
		}
	}

	changeEvent() {
		if (!isOnComposition) {
			console.log('改变');
		}
	}
  render() {
		return (
          <div>
              <input type="text" id="test" onChange={this.changeEvent.bind(this)}
                     onCompositionStart={this.handleComposition.bind(this)}
                     onCompositionUpdate={this.handleComposition.bind(this)}
                     onCompositionEnd={this.handleComposition.bind(this)}/>
          </div>
		)
	}
```

## 四 非受控组件

### 4.1 非受控组件示例

如果一个表单组件没有 value props（单选按钮和复选框对应的是 checked prop）时，就可以称为非。相应地，你可以使用 defaultValue 和 defaultChecked prop 来表示组件的默认状态。

```js
import React, { Component } from 'react'
class App extends Component {
  constructor(props) {
    super(props)
    this.handleSubmit = this.handleSubmit.bind(this)
  }
  handleSubmit(e) {
    e.preventDefault()
    // 这里使用 React 提供的 ref prop 来操作 DOM
    // 当然，也可以使用原生的接口，如 document.querySelector
    const { value } = this.refs.name
    console.log(value)
  }
  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <input ref="name" type="text" defaultValue="Hangzhou" />
        <button type="submit">Submit</button>
      </form>
    )
  }
}
```

在 React 中，非受控组件是一种反模式，它的值不受组件自身的 state 或 props 控制。通常，需要通过为其添加 ref prop 来访问渲染后的底层 DOM 元素。

### 4.2 对比受控组件和非受控组件

我们刚才看到通过 defaultValue 或者 defaultChecked 来设置表单的默认值，它仅会被渲染
一次，在后续的渲染时并不起作用。下面对比以下两个示例。

```js
// 将输入的字母转化为大写展示：
<input
  value={this.state.value}
  onChange={e => {
  this.setState({ value: e.target.value.toUpperCase() })
}}
/>
// 直接展示输入的字母：
<input
  defaultValue={this.state.value}
  onChange={e => {
  this.setState({ value: e.target.value.toUpperCase() })
}}
/>
```

在受控组件中，可以将用户输入的英文字母转化为大写后输出展示，而在非受控组件中则不会。而如果不对受控组件绑定 change 事件，我们在文本框中输入任何值都不会起作用。多数情况下，对于非受控组件，我们并不需要提供 change 事件。通过上面的示例可以看出，受控组件和非受控组件的最大区别是：非受控组件的状态并不会受应用状态的控制，应用中也多了局部组件状态，而受控组件的值来自于组件的 state。

### 4.5
