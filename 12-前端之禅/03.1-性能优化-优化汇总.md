# 03-性能优化 -1-优化汇总

## 一 HTML 优化

### 1.1 简化 HTML 嵌套层级

浏览器在解析 HTML 文件时，会将标签挂载在 DOM 树中，标签嵌套的层级越深，DOM 树就越深。由于 DOM 树在访问时需要遍历，层级深会对遍历性能造成影响。

现代浏览器拥有很强的遍历算法，但是这并不代表算法可以将遍历时间降低到 0，适当减少 HTML 层级，仍然是优化 HTML 性能的策略之一。

对于 MVVM 框架来说，层级嵌套同样不能过深，比如 vue 中需要通过 replace() 函数绑定 setter、getter：

```js
while (node.childNodes.length) {
  replace(node)
}
```

这是一个递归函数，每多一层嵌套，递归的深度就多一层，占用内存、时间消耗都会变多。

推荐组件的嵌套不超过 3 层。

### 1.2 减少空格标签、无用标签滥用

很多没有多少实际作用的标签位可以无需书写标签，通过伪元素的方式生成。

### 1.3 prefetch、preload 预加载 link 标签资源

link 标签设置 `rel="prefetch"` 可以让浏览器在空闲时间下载该内容并缓存，下次再访问则是从缓存中获取，请求状态码为 304。

link 标签设置 `rel="dns-prefetch"` 可以让浏览器在空闲时间预先解析 link 中该网址的 dns。

llink 标签设置 `rel="preload"` 也会对资源进行预加载：

```html
<link rel="preload" href="common.js" as="script" />
```

preload 预加载这个 js 文件后，不会被执行，而是在需要该 js 时候，动态插入执行，比如点击时执行：

```js
btn.addEventListener('click', function () {
  let script = document.createElement('script')
  script.src = 'common.js'
  document.body.appendChild(script)
})
```

使用 preload 预加载，在页面开始显示之前，会多出一个请求，只不过该请求实在浏览器空闲时间完成，后续需要该资源时则无需再次请求。这样做牺牲了一定的首屏渲染时间，但是提升了整体性能。比如实际开发中，SSR 的导航需要从服务端获取，那么这个 js 可以使用 preload 加载。

不过当代浏览器一般都启用的隐式的预解析，无需专门设置。

### 1.4 img 标签大小

img 很容易因为图像大小不同造成页面重绘、重排，在允许的情况下，可以固定其大小。

### 1.5 src 与 href 值

src 和 href 的值为空时，页面找不到资源，会认为需要加载当前页面，从而拖慢一定的加载速度，一般需要对这些内容进行限定：

```html
<a href="javascript:;"></a>
```

## 二 CSS 优化

### 2.1 CSS 选择器层级不能过深

层级过深的选择器会让代码不利于维护，也会对性能产生一定的影响。

### 2.2 利用继承性

类似 font、text-align、text-indent、visibility 这种支持继承的属性，在 CSS 中尽量利用其继承特性减少重复书写，既能提升开发效率，也能让浏览器在解析 CSS 时，减少重复解析。

### 2.2 尽量使用 CSS 替代 JavaScript 实现动态效果

比如类似 :focus 这样的伪类能够很好的实现效果，而使用 JS 控制则会造成代码的繁冗。
比如 CSS3 的动画也具有同样的效果，浏览器对 CSS 动画进行了优化，更加流畅，比如 transform 会触发 GPU 硬件加速。

### 2.3 尽量较少使用代价昂贵的 CSS 样式

一些 CSS 样式会造成大量的运算，代价昂贵，比如：box-shadows、gradients、filter、opacity、border-radius。

### 2.4 关注重排重绘

### 2.5 减少 float 滥用

float 的本意是：实现文字环绕，浮动后元素不受外部影响，自成一行，且会造成父元素高度塌陷，这需要消耗更多的浏览器计算性能。

通常需要 div 横向排列时，可以使用 `inline-block` 方式替代，后者没有脱离文档流，性能上略优。

### 2.6 合理利用雪碧图

雪碧图可以用来合并请求，在很大程度上缓解网络性能压力！

不过雪碧图也有缺陷：更改雪碧图中一个小的 UI 的尺寸，可能会引起大量使用该雪碧图的地方的修改。

## 三 JavaScript 优化

### 3.1 合理利用定时器

定时器内部如果对 DOM 进行了操作，需要格外小心，很容易引起重排、重绘。而且要注意及时清除定时器。

### 3.2 JS 控制动画

尽量使用 CSS3 控制动画，性能更好。

### 3.3 利用事件委托

比如给 ul 中的 li 绑定事件，其实给 ul 本身绑定即可，li 的数量过多会绑定过多的事件函数，影响程序性能。

### 3.4 避免事件重复监听

需要引入防抖、节流来控制事件重复监听。

当然也有一些特殊场景：比如秒杀活动中，只希望用户点击下单一次，其实在点击后，可以直接添加移除事件监听的函数。

### 3.5 减少全局变量的使用

模块化、声明一个容器对象包裹私有对象都可以缓解全局变量过多问题。

## 四 资源加载

### 4.0 资源概念

显示一个网址需要加载的资源包括：HTML、CSS、JS、图片、音视频等等。大多时候，资源的加载性能对网页的性能影响能占据绝对作用。

### 4.1 DNS 预解析

比如 link 标签设置 dns-pretech，不过当代浏览器一般都启用的隐式的预解析，无需专门设置。

### 4.2 添加 CDN 支持

静态资源可以通过放置在 CDN 上进行加速，这是因为 CDN 会选择离用户最新的服务商提供资源。

同样，这里有个细节：同源下浏览器最大并发请求数为 6 个，即同一时间只能同时下载 6 张图片，但是通过使用不同的 CDN 可以突破该限制。

### 4.3 HTTP 缓存

浏览器一般通过资源请求头部的参数来判断这个资源是走请求、还是走缓存：

```txt
1)  判断是否命中强缓存，若命中则直接加载缓存资源。此时状态码为 200，Size 列会显示 from memory cache
2)  若未命中强缓存，则请求服务器获取资源。但是服务器会判定资源是否有效（协商缓存）：
        如果有效，则服务器不返回资源，只返回 304 状态码，浏览器收到响应后从本地缓存加载资源
        如果无效，则服务器返回资源，状态码为 200
```

强缓存由两个参数控制：

- Expires：服务器资源过期时间点。由于客户端可以随意修改自己的时间，会产生混乱。
- Cache-Control：服务器资源过期的相对时间，且包含多个字段，控制粒度更细。Cache-Control 优先级比 Expires 高。

强缓存没有被命中时，由以下参数控制协商缓存：

- Etag：如果资源的头部带有 Etag，则浏览器发送带有 if-Node-Match 的请求头。若服务端的 Etag 和 if-Node-Match 相同则资源未更新，返回 304。若不同，则返回 200，要求获取资源。
- Last-Modified：若资源信息头部没有 Etag，则判断是否有 Last-Modified，若有则发送 if-Modified-Since，。若服务端的 Last-Modified <= if-Modified-Since，即资源未改变，返回 304，否则返回 200 重新获取。

### 4.4 懒加载

懒加载即按需加载，对于一些图片、视频等媒体资源，列表无需全部展示，而是先展示可视区部分要展示的内容，浏览完可视区后，重新把接下来的数据加载出来。

### 4.5 分页加载

是指数据并未被完全请求到前台，只请求了当前页面的一部分，用户点击下一页，则根据 limit（每页显示多少行）、page（页码）重新从服务端获取数据。

### 4.6 避免重复加载

贴士：iframe 具备阻隔性质，无法使用父页面中已经加载的资源。尽量不要使用 iframe。

### 五 资源优化

### 5.1 减小资源体积

如 CSS 压缩、JavaScript 代码压缩、图片 base64 化。

通过一个图片也可以才使用大、中、小三种展示方式，来减轻压力。

策略实现：

- 代码压缩：可以有效降低请求的代码文件的大小，如无效代码删除、html 删除换行符等
- 代码合并：可以有效减少请求的代码文件的数量。但是由于合并了多个文件，容易引起缓存失效，同时文件过大也会造成渲染延迟问题。
- 图片合并：雪碧图，合并了多个图片请求为一个雪碧图请求。
- 图片内嵌：转换为 base64、svg 等，这时候就没有请求了，已经成为原生的 html 可解析内容

实践方案：

- 代码压缩使用一些 fis3、现在工具等方式实现压缩合并
- 前端自己压缩合并：使用工程化开发方案，如 gulp、webpack
- 后端压缩：模板引擎自动压缩等
- 图片压缩与合并：精灵图、base64、svg

### 5.2 合理利用 浏览器数据存储机制

精简 cookie：浏览器每次请求都会发送 cookie，对 cookie 进行精简可以适量减轻压力。

利用 sessionStorage、localStorage、indexDB 存储机制也能存储一些无法服务端控制的资源。

### 5.3 减少与服务端交互次数

比如利用中间层合并后端服务是最常见的策略。

此外之前提到的雪碧图、cookie、storage 等都属于尽量本地处理的策略。

## 六 缓存策略详解

### 6.1 cache-control 与 expires

cache-control 字段：多个字段之间逗号隔开

- public：文件的公共性，如 CDN 资源，与之对应的还有 private
- max-age：第一次访问该资源时刻起，max-age 时间内都从缓存获取，不会发起新请求
- s-maxage：针对 public 策略的文件设置的最大缓存时间
- no-cache：一般搭配 max-age=0 使用，代表每次请求资源都要从服务端获取，而不是从缓存中获取，并不是禁止了缓存策略，no-store 才是禁止了缓存

示例：

```txt
Response Headers
  cache-control:max-age=315360000               # 第一次访问该资源时刻起，max-age 时间内都从缓存获取
  expires: Sun,15 Aug2027 01:09:24 GMT          # 与 max-age 类似，但是优先级较低。
```

总结：max-age 键值与 http 头中的 expires 字段作用一致，都会让资源直接从缓存中获取，不再请求服务端。expires 优先级更低，因为 expires 字段是 http1.0 的，http1.1 决定缓存策略交给 cache-control 统一管理。

### 6.2 Last-Modified 与 If-Modified-Since

last-modified 与 if-modified-since 是客户端与服务端的协商缓存机制，需要与 cache-control 配合使用：

- last-modified：response header，服务端告诉客户端资源的最后修改时间
- if-modified-since：request header，客户端告诉服务端资源的在客户端所知道的最后修改时间

### 6.3 ETag 与 If-None-Match

Last-Modified 的机制上存在一定的缺陷：文件的最后修改时间出现了变化，但是其内容其实并未出现变化，这时候会造成不必要的缓存失效。

- ETag：response header，其本质是文件内容的 hash 值，只有文件内容改变了，Etag 才会变化
- If-None-Match：request header

### 6.4 分级缓存策略

- 第一层：使用 200 状态码，当本地没有缓存、下一层失效、用户 Ctrol+F5 强制刷新，则浏览器会从服务端下载最新数据
- 第二层：使用 304 状态码，当下一层失效、用户 F5 刷新，则浏览器会发送请求给服务端，服务端若没有变化，则返回 304。本层由 last-modified、etag 控制
- 第三层：使用 200 状态码，浏览器访问自己的缓存，由于 cache-control、expires 控制

## 七 项目实践优化

### 7.1 长列表性能优化

方案一：每次只渲染一部分，比如 10 条数据，滚动完毕前获取下一部分数据。不适用于超大列表数据。

方案二：可视区渲染，比如使用 react-virtualized。原理：只渲染页面可视区的列表项，非可视区数据不渲染，滚动时动态更新列表。（为了避免滑动过快，也会额外提前加载一部分数据）。适用于微博、聊天、大表格等。

formik 库：react 表单库。
