# 01.1-内存管理-垃圾回收算法

## 一 垃圾回收概念

### 1.1 内存的申请与释放

程序的运行需要操作系统提供内存支持，比如声明的变量、函数等都需要内存来进行存储。这些从操作系统申请的内存，在无需使用时必须进行释放，否则长时间占用操作系统资源，会引起不必要的性能降低、资源浪费，比如申请的变量已经在函数中使用完毕，其他地方无需使用，这个变量所占据的内存就需要释放！

简单来说：内存要一般有申请、使用、释放三个流程。

简单展示 C 语言内存的申请与释放操作：

```c++
#include <stdio.h>
#include <stdlib.h>

int main(){
    // 申请：申请一个数组内存来存储整型数据，元素个数为5
    int *arr = malloc(5 * sizeof(int));

    // 使用：制作数组数据，并打印数据
    for(int i = 0; i < 5; i++){
        arr[i] = i + 1;
    }
    for(int i = 0; i < 5; i++){
        printf("arr[%d]=%d\n", i, arr[i]);
    }

    // 释放：
    free(arr);

    // 此时再打印数据会报错
    return 0;
}
```

从上看出，C 语言是需要手动进行内存管理的，通过 `malloc()` 函数申请内存，通过 `free()` 函数释放内存，这对开发者来说造成了极大的心理负担，尤其在大型复杂项目上，内存的申请与释放更要小心。

### 1.2 自动销毁

一些适合快速开发普通业务的编程语言，如 Java、JavaScript 等语言的引擎内部会对内存进行自动申请、释放，能够有效提升开发效率，称为**垃圾回收**，其基本思路是：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。

js 示例：

```js
// 申请
let arr = [1, 2, 3, 4, 5]

// 使用
arr.forEach((item) => {
  console.log(item)
})

// 释放:JS 没有释放的 API，是自动释放的，设置为 null 也不会直接触发释放，只是会清除其引用。
arr = null
```

## 二 垃圾回收算法

### 2.0 垃圾回收算法汇总

在 JavaScript 中，一般认为以下内存需要垃圾回收：

- 对象不再被引用
- 对象不能从根（全局执行上下文）上访问到，即是不可达对象

垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，意味着靠算法是解决不了的。我们以函数中局部变量的正常生命周期为例。函数中的局部变量会在函数执行时存在。此时，栈（或堆）内存会分配空间以保存相应的值。函数在内部使用了变量，然后退出。此时，就不再需要那个局部变量了，它占用的内存可以释放，供后面使用。这种情况下显然不再需要局部变量了，但并不是所有时候都会这么明显。垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。

垃圾回收常用的两种标记策略是：**引用计数**、**标记清除**，在使用这些策略进行回收是，还会用到**标记整理**、**分代回收**等算法机制：

- 引用计数：记录申请的内存被引用的数，当被引用数为 0 时，销毁该内存。可以即时回收垃圾对象，但是无法解决循环引用问题。
- 标记清除：遍历所有对象，对活动的对象进行标记，对没有被标记的对象进行清除。可以解决循环引用问题，但不能即时回收垃圾对象，且会产生内存碎片。

### 2.1 引用计数

引用计数是一个比较古老的垃圾回收算法，当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。

引用计算 GC 示例：

```js
let obj = { name: 'zs' }

let other = obj

obj = null
console.log(other.name) // zs

other = null
console.log(other.name) // 错误
```

引用计数算法优点：

- 发现垃圾后能够立即回收
- 最大限度减少程序暂停（内存占满时系统忙于执行垃圾清理）

引用计数算法缺点：

- 开销大：程序需要使用一个数值监控数据的引用数，该数值需要时刻被监控，这会造成时间、空间的开销放大
- 循环引用无法回收：应用计数无法解决循环依赖问题，会引起内泄露

循环依赖即循环引用指的是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的引用：

```js
function problem() {
  let A = {}
  let B = {}
  A.other = B
  B.other = A
}
```

上述示例中，全局作用已经找不到 A 和 B，但是在函数内部 A 与 B 是互相引用者，即产生了循环引用，是无法使用引用计数进行清除的，因为当函数执行完毕后，A 和 B 还将继续存在，因为它们的引用次数永远不会是 0。假如这个函数被重复多次调用，就会导致大量内存得不到回收。

### 2.2 标记清除

标记清除算法（mark-and-sweep）是最常见的垃圾回收策略，包含两个阶段：

- 标记阶段：遍历所有对象，并对活动对象（可达对象）进行标记
- 标记清除阶段：标记后，清除并回收没有标记的对象（也会抹掉已经可达对象的标记便于下一次 GC 工作）

变量进入上下文时，比如在函数内部声明一个变量，这个变量会被加上存在于上下文中的标记，当变量离开上下文时，也会被加上离开上下文的标记。垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。

贴士：给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。

标记清除算法优点：

- 能解决循环引用问题

标记清除算法缺点：

- 不能立即回收垃圾对象，需要等到遍历标记完成后才能清除，且会导致程序暂停
- 容易导致**内存碎片**

```js
let obj = { name: 'zs' }

let other = obj

obj = null

// 这里清除了 obj 对 {name: 'zs'} 的引用，但是 other 仍然在引用着 obj
// 所以 {name: 'zs'} 仍然是可达的
console.log(other.name) // zs
```

如果该对象不可达，就会执行标记清除。所以在循环引用案例中，A，B 对象都离开了作用域，变为不可达，就不会再有循环应用的问题了。

但是标记清除释放的空间地址存在不连续的现象，会导致内存的浪费（碎片化）。比如：刚刚回收了 2 部分空间，1 部分连续内存是 5 个字节，1 部分连续内存是 2 个字节，现在创建的一个新的变量需要 4 个字节，那么就只用这个 5 个字节的空间，剩下 1 个字节未被使用，被浪费掉了。

### 2.3 标记整理

V8 中使用标记整理来增强标记清除，其标记阶段工作原理与标记清除一致，但是在清除阶段会先执行整理，移动对象的位置，使回收的空间尽可能形成连续的，减少碎片。

## 三 垃圾回收的性能

垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。尤其是在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代码时就要做到：无论什么时候开始
收集垃圾，都能让它尽快结束工作。

现代垃圾回收程序会基于对 JavaScript 运行时环境的探测来决定何时运行。探测机制因引擎而异，但基本上都是根据已分配对象的大小和数量来判断的。比如，根据 V8 团队 2016 年的一篇博文的说法：“在一次完整的垃圾回收之后， V8 的堆增长策略会根据活跃对象的数量外加一些余量来确定何时再次垃圾回收。”

v8 的垃圾回收策略采用了更高效的**分代式垃圾回收机制**，详细介绍见第 3 节。
