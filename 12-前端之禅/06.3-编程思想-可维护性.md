# 08-可维护性

## 一 可维护代码概念

可维护代码特点：

```txt
容易理解：无须求助原始开发者，任何人一看代码就知道它是干什么的，以它是怎么实现的。
符合常识：代码中的一切都显得顺理成章，无论操作有多么复杂。
容易适配：即使数据发生变化也不用完全重写。
容易扩展：代码架构经过认真设计，支持未来扩展核心功能。
容易调试：出问题时，代码可以给出明确的信息，通过它能直接定位问题。
```

## 二 编码规范

### 2.1 可读性

代码缩进是保证可读性的重要基础。如果所有人都使用相同的缩进，整个项目的代码就会更容易让人看懂。缩进通常要使用空格数而不是 Tab（制表符）来定义，因为后者在不同文本编辑器中的显示不同。一般来说，缩进是 4 个空格，当然具体多少个可以自己定。

可读性的另一方面是代码注释：

```txt
函数和方法。每个函数和方法都应该有注释来描述其用途，以及完成任务所用的算法。同时，也写清使用这个函数或方法的前提（假设）、每个参数的含义，以及函数是否返回值（因为通过函数定义看不出来）。

大型代码块。多行代码但用于完成单一任务的，应该在前面给出注释，把要完成的任务写清楚。

复杂的算法。如果使用了独特的方法解决问题，要通过注释解释明白。这样不仅可以帮助别人查看代码，也可以帮助自己今后查看代码。

使用黑科技。由于浏览器之间的差异，JavaScript 代码中通常包含一些黑科技。不要假设其他人一看就能明白某个黑科技是为了解决某个浏览器的什么问题。如果某个浏览器不能使用正常方式达到目的，那要在注释里把黑科技的用途写出来。这样可以避免别人误以为黑科技没有用而把它“修复”掉，结果你已解决的问题又会出现。
```

### 2.2 变量和函数名

命名的通用规则：

```txt
变量名应该是名词，例如 car 或 person。

函数名应该以动词开始，例如 getName()。返回布尔值的函数通常以 is 开头，比如 isEnabled()。

对变量和函数都使用符合逻辑的名称，不用担心长度。长名字的问题可以通过后处理和压缩解决

变量、函数和方法应该以小写字母开头，使用驼峰大小写（camelCase）形式，如 getName() 和 isPerson。类名应该首字母大写，如 Person、RequestFactory。常量值应该全部大写并以下划线相接，比如 REQUEST_TIMEOUT。

名称要尽量用描述性和直观的词汇，但不要过于冗长。getName() 一看就知道会返回名称，而 PersonFactory 一看就知道会产生某个 Person 对象或实体。
```

### 2.3 变量类型透明化

第一种标明变量类型的方式是通过初始化。定义变量时，应该立即将其初始化为一个将来要使用的类型值。

第二种标明变量类型的方式是使用匈牙利表示法。匈牙利表示法指的是在变量名前面前缀一个或多个字符表示数据类型。

```js
// 使用匈牙利表示法标明数据类型
let bFound // 布尔值
let iCount // 整数
let sName // 字符串
let oPerson // 对象
```

第三种方式使用 TypeScript、Flow 等。

## 三 松耦合

解耦 HTML/JavaScript：应该避免在 JavaScript 中创建大量 HTML。HTML 渲染应该尽可能与 JavaScript 分开

同样适用于 CSS 与 JS。

应用逻辑与事件处理程序分开：

```js
function validateValue(value) {
  value = 5 * parseInt(value)
  if (value > 10) {
    document.getElementById('error-msg').style.display = 'block'
  }
}
function handleKeyPress(event) {
  if (event.keyCode == 13) {
    let target = event.target
    validateValue(target.value)
  }
}
```

## 四 编码惯例

### 4.1 尊重对象所有权

在企业开发中，非常重要的编码惯例就是尊重对象所有权，这意味着不要修改不属于你的对象。简单来讲，如果你不负责创建和维护某个对象及其构造函数或方法，就不应该对其进行任何修改：

```txt
尽量不要给实例或原型添加属性。
尽量不要给实例或原型添加方法。
不要重定义已有的方法
```

有个流行的 Prototype 库就发生过类似的事件。该库在 document 对象上实现了 getElementsByClassName() 方法，返回一个 Array 的实例，而这个实例上还增加了 each() 方法。jQuery 的作者 John Resig 后来在自己的博客上分析了这个问题造成的影响。他在博客中指出这个问题是由于浏览器也原生实现了相同的 getElementsByClassName() 方法造成的，Prototype 的同名方法返回的是 Array 而非 NodeList，NodeList 没有 each() 方法。使用这个库的开发者之前会写这样的代码：

```js
document.getElementsByClassName('selected').each(Element.hide)
```

虽然这样写在没有原生实现 getElementsByClassName() 方法的浏览器里没有问题，但在实现它的浏览器里就会出问题。这是因为两个同名方法返回的结果不一样。我们不能预见浏览器厂商将来会怎么修改原生对象，因此不管怎么修改它们都可能在将来某个时刻出现冲突时导致问题。

最好的方法是永远不要修改不属于你的对象，有你自己创建的才是你的对象，包括自定义类型和对象字面量。Array、document 等对象都不是你的，因为在你的代码执行之前它们已经存在了。可以按如下这样为对象添加新功能：

```js
创建包含想要功能的新对象，通过它与别人的对象交互。
创建新自定义类型继承本来想要修改的类型，可以给自定义类型添加新功能。
```

### 4.2 少使用声明全局变量

最多可以创建一个全局变量，作为其他对象和函数的命名空间。来看下面的例子：

```js
// 两个全局变量：不要！
var name = 'Nicholas'
function sayName() {
  console.log(name)
}

// 以上代码声明了两个全局变量：name 和 sayName()。可以像下面这样把它们包含在一个对象中：
// 一个全局变量：推荐
var MyApplication = {
  name: 'Nicholas',
  sayName: function () {
    console.log(this.name)
  },
}
```
