# 09-前端中的测试

## 一 测试定义

### 1.1 常见测试分类

针对小型项目，手动运行查看错误，是最为快捷的方式。但是对一个整合了很多结构、系统的项目来说，手动测试为极大增加排错负担，自动化测试可以在一定程度上减少拍错时间。

一些常见的自动化测试有：编写自动测试脚本、调用应用程序中的函数、对比程序渲染结果等等。自动化测试最大的好处是：检测应用程序是否能够正常工作。

对应用程序执行的正确性进行测试的常见方式有：

- 端到端测试：对整个应用程序及其依赖进行测试
- 单元测试：对程序模块进行测试
- 快照测试：传统的快照测试方式是在浏览器中启动程序后获取其渲染页面的屏幕截图，新截图与旧截图进行比较。

对应用程序的性能进行测试的常见方式有：

- 基准测试：用来统计多少时间内执行了多少次某个方法
- 压力测试：压测一般是对网络接口进行压力测试

### 1.2 测试覆盖率

测试覆盖率是度量自动化测试的指标之一，使用百分比表示，100% 代码覆盖率即代表执行测试期间每行代码都会被运行，0% 意味着测试时任何一行代码都未被执行。

大多数情况下，100% 覆盖率完全没有意义，100% 覆盖率会让开发进度变得极度缓慢，获得的收益远不能抵消时间的流式。同样，为前端的组件编写单元测试很重要，但是如果组件的每个属性都编写测试，就会创建一个低效的、减缓开发速度的测试套件。

一个好的组件的单元测试应该始终可以触发一个输入，并断言组件产生正确的输出，要做到这样，应该：从开发者使用组件又不知道组件内部实现的角度编写测试。

组件的输入一般指用户的操作，如：单机按钮。输出一般指 DOM 的变化，如：生成 DOM 节点。
输入：

```txt
组件的 props
用户操作
事件
store 数据
```

输出：

```txt
发射出去的事件
外部函数引用
```

示例：一个授权组件，接收是否已授权 prop 参数 flag，flag 为 true，则渲染：`已被授权`，否则渲染：`未被授权`。flag 即是输入，渲染的信息即输出。

### 1.3 测试风格

- TDD（Test Driven Development）：测试驱动开发，关注所有功能是否被正确实现，每一个功能具备对应的测试用例。TDD 的表达方式偏向于功能说明书。倡导先写测试程序，然后编码实现其功能。
- BDD（Behavior Driven Development）：行为驱动开发，鼓励软件开发中的相关人员进行协作，书写非程序员刻度的测试用例扩展 TDD。关注整体行为是否符合预期，适合自顶向下的设计方式。BDD 的表达方式接近于自然语言。

一些实践：并不一定要严格按照 TDD 等风格来进行开发，比如开发 Vue 组件的顺序：

```txt
1 为每个组件编写单元测试、源码
2 调整组件直到满足需求
3 为已完成组件添加快照测试
4 在浏览器中手动调试
5 编写端到端测试
```

## 二 单元测试

### 2.1 单元测试概念

单元测试（模块测试），用来实现对程序模块的检验。在编写可测试代码时，可以遵循以下原则：

- 单一职责：代码段的职业越多，单元测试就需要构造更多的输入，同时也会影响代码的后期维护
- 接口抽象：通过对程序代码进行接口抽象后，可以针对接口进行测试，而具体代码的变化则不会影响为接口编写的单元测试
- 层次分离：层次分离其实是单一职责原则在项目上的一个整体实现，单元测试应该保证可以逐层测试，逐层保证。

单元测试主要包含：断言、测试框架、测试用例、测试覆盖率、mock 模拟异常、持续集成等几个方面。

### 2.2 测试框架 Mocha

流行的单元测试框架有 Mocha。Mocha 并不是关注测试本身，需要配合 Chai 这样的断言库来编写，Mocha 提供了一套单元测试的输出规范。

```txt
npm i mocha -g
```

mocha 对 TDD 方式的支持：采用 suite 和 test 完成，suite 实现了多层级描述，测试用例使用 test。提供的钩子函数有 setup、teardown，分别表示 suite 前、suit 后执行。

```js
suite('Array', function () {
  setup(function () {
    // ...
  })

  suite('#indexOf()', function () {
    test('should return -1 when not present', function () {
      assert.equal(-1, [1, 2, 3].indexOf(4))
    })
  })
})
```

mocha 对 BDD 方式的支持：主要采用 describe 和 it 进行组织，describe 可以描述多层级结构，具体到测试用例时，可以使用 it。另外内部提供了 before、after、beforeEache、afterEach 这 4 个钩子函数，用于协助 describe 中测试用例的准备、安装、卸载、回收工作。before 和 after 分别在进入和退出 describe 时触发，beforeEach 和 afterEach 分别在 describe 中每一个测试用例（it）执行前、执行后触发。

```js
describe('Array', function () {
  before(function () {
    // ...
  })

  describe('#indexOf()', function () {
    it('should return -1 when not present', function () {})
  })
})
```

mocha 框架与断言之间是解耦的，既可以使用 Node 原生的 assert 模块，也可以使用 should.js、chai 等第三方断言库。

mocha 导出测试报告也支持多种格式，一般使用 json 格式。

mocha 对异步的支持：

```js
it('fs.readFile should be ok', function (done) {
  fs.readFile('file_path', 'utf-8', function (err, data) {
    should.not.exist(err)
    done()
  })
})
```

## 三 测试框架 jest

### 3.1 jest 简介与安装

jest 由 facebook 出品，集成了企业级开发中常用的测试需求工具，是一款简便、强大的综合测试框架。集成了大部分测试需要的功能：

- 断言：jest 内置了断言，而 mocha 则需要安装 chai 或者其他断言库
- 异步支持：jest 支持异步代码的测试
- mock：jest 内置了 mock 服务，mocha 需要安装 sinon
- 代码覆盖率测试：jest 内置了覆盖率测试服务，mocha 需要安装 istanbul

### 3.2 TODO

## 四 性能测试

### 4.1 基准测试

如果要测试某段代码运行速度，使用下面的方式是极不规范的：

```js
var start = new Date().getTime() // 或者Date.now()
// 进行一些操作
var end = new Date().getTime()
```

这段方法只能得知特别的一次运行消耗了大概这么长时间，这段程序是不是总是以这样的速度运行是无法得知的，会收到引擎、系统什么影响也无法得知。更麻烦的是，我们无法得知这个运算测试的环境是否过度优化了。有可能 JavaScript 引擎找到了什么方法来优化你这个独立的测试用例，但在更真实的程序中是无法进行这样的优化
的，那么这个运算就会比测试时跑得慢。

对这段代码使用循环包裹，重复运算 100 次，取平均值的做法也是不可取的。简单的数学平均值绝对不足以对你要外推到整个应用范围的性能作出判断。迭代 100 次，
即使只有几个（过高或过低的）的异常值也可以影响整个平均值，然后在重复应用这个结论的时候，你还会扩散这个误差，产生更大的欺骗性。

更可靠的方式是不以固定次数执行运算，转而循环运行测试，直到达到某个固定的时间。但如何确定要执行多长时间呢？你可能会猜测，执行时间应该是你的运算执行的单次时长的若干倍。错。

基准测试用来统计多少时间内执行了多少次某个方法。假设要测试 ES5 中的 Array.prototype.map 和循环提取值两种方式，他们都是迭代一个数组，根据回调函数执行的返回值得到的一个新的数组，相关代码如下：

```js
var nativeMap = function (arr, callback) {
  return arr.map(callback)
}

var customMap = function (arr, callback) {
  var ret = []
  for (var i = 0; i < arr.length; i++) {
    ret.push(callback(arr[i], i, arr))
  }
  return ret
}
```

比较简单直接的方式就是构造相同的输入数据，然后执行相同的次数，最后比较时间，所以可以写一个方法来执行：

```js
var run = function (name, times, fn, arr, callback) {
    var start = (new Date()).getTime();
    for (var i = 0; i < times; i++) {
        fn(arr, callback);
    }
    var end = (new Date()).getTime();
    console.log('Running s d times cost d ms', name, times, end % % % - start);
};
```

最后分别调用 1000000 次：

```js
var callback = function (item) {
  return item
}
run('nativeMap', 1000000, nativeMap, [0, 1, 2, 3, 5, 6], callback)
run('customMap', 1000000, customMap, [0, 1, 2, 3, 5, 6], callback)
```

由上看出，执行相同的任务，map 耗费的时间大约是直接 for 循环的 5-7 倍以上。

实际上，重复执行的时间长度应该根据使用的定时器的精度而定，专门用来最小化不精确性。定时器的精度越低，你需要运行的时间就越长，这样才能确保错误率最小化。15ms 的
定时器对于精确的性能测试来说是非常差劲的。要最小化它的不确定性（也就是出错率）到小于 1%，需要把你的每轮测试迭代运行 750ms。而 1ms 定时器时只需要每轮运行 50ms
就可以达到同样的置信度。但是，这只是单独的一个例子。要确保把异常因素排除，你需要大量的样本来平均化。你还会想要知道最差样本有多慢，最好的样本有多快，以及最好和最差情况之间的偏离度有多大，等等。你需要知道的不仅仅是一个告诉你某个东西跑得有多快的数字，还需要得到某个可以计量的测量值告诉你这个数字的可信度有多高。

比较好的基准测试框架式 benchmark 第三方模块。

### 4.2 压力测试

基准测试一般是对基本的方法进行测试，压测一般是对网络接口进行压力测试。压测需要考察的指标有：吞吐率、响应时间、并发数。

常用的压测工具有：ab、http_load，使用 ab 工具如下：

```txt
# 10 个并发用户持续 3 秒向服务端发送请求
ab -c 10 -t 3 http://localhost:8001/
```
