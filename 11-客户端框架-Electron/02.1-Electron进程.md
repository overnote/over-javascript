# 02.1-Electron 进程

## 零 Electron 原理

Electron 内部主要的 2 部分就是：Chromium、Node.js，所以 Electron 的架构也受到了这 2 个模块的影响！

现代浏览器为了防止页面、插件的崩溃导致浏览器崩溃，都会进行隔离设计！即：把每个页面约束在单独的进程中，甚至还会限制每个页面进程对其他进程和系统的访问！

Chromium 把管理页面、管理选项卡、管理插件的进程称之为主进程，把特定于页面的进程称之为渲染进程。渲染进程通过 Blink 内核引擎来渲染 HTML 文档，渲染进程和主进程则通过 IPC 管道进行通信！主进程则负责监视追踪这些渲染进程，一旦渲染进程崩溃，则主进程控制着界面，提示用户重新加载界面，用户刷新后，主进程会创建一个新的渲染进程来服务！

每个渲染进程都对应一个全局的 RenderProcess 对象，和一个或多个 RenderView 对象。 RenderProcess 对象负责与主进程通信并管理这些对象 RenderView 对象。当然同样的渲染进程也会支持复用的情况。

渲染进程不提供资源服务，由于渲染进程单独运行，页面的脚本也在此进程中，当页面需要访问网络、本地资源时，就需要渲染进程发消息给主进程，由主进程完成这些工作。如果主进程判定这些操作不符合，如跨域等，则可以拒绝服务，这也是浏览器的沙箱模式。

浏览器的多进程模式也可以在用户内存较低时，将占用的部分内存交换到磁盘上，以保证用户可见的进程更具响应性。

当然多进程也带来了更复杂的通信模型、更多的内存、CPU 的消耗！

## 一 Electron 中的主进程与渲染进程

一个 Electron 应用只有一个主进程，但可以有多个渲染进程：

- 主进程：由 Electron 创建，并从口文件开始执行代码的进程。主进程用来监听程序的生命周期事件、管理窗口（渲染进程）、加载页面、程序关闭后回收资源等。
- 渲染进程：一个 BrowserWindow 实例代表一个渲染进程，若该实例被销毁，则渲染进程也会终结。渲染界面负责完成界面渲染、接收用户输入、响应用户交互。

![electron 应用架构](./../images/electron/electron-00.drawio.svg)

在 HelloWorld 示例中，`electron .` 的入口文件是 `main.js` 文件中的代码，即启动了一个进程，并且执行该代码，创建了窗口、加载了`index.html`，而`index.html`中的代码则会运行在 Electron 的渲染进程中。

贴士：

- 主进程负责管理所有窗口及其对应的渲染进程，开启 `nodeIntegration` 后，渲染进程也有能力访问 Node 的 API。
- GUI 的操作，如：创建窗口、创建菜单只能在主进程中完成，如果需要渲染进程来执行创建，必须让渲染进程发送消息给主进程，主进程接收到消息后执行创建，也可以使用 remote 模块来完成。

Electron 中模块的归属：

```txt
主进程模块：app、BrowserView、autoUpdater、contentTracing、dialog、gloablShortcut、ipcMainMenu、
            MenuItem、net、netLog、Notification、powerMonitor、powerSaveBlocker、protocol、screen、session、systemPreferences、TouchBar、Tray、webContents

渲染进程模块：desktopCapturer。ipcRenderer、remote、webFrame

公用模块：clipboard、crashReporter、nativeImage、shell
```

## 二 进程调试

### 2.1 调试主进程

点击 vscode 的左侧 debug 图标，接着点击 `create a launch.json file`，选择弹出的 `Node` 选项，此时会在根目录创建文件：`.vscode/launch.json`，内容可以修改为如下所示：

```json
{
  // Use IntelliSense to learn about possible attributes.
  // Hover to view descriptions of existing attributes.
  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "调试主进程",
      "skipFiles": ["<node_internals>/**"],
      "program": "${workspaceFolder}/main.js",
      "cwd": "${workspaceFolder}",
      "runtimeExecutable": "${workspaceRoot}/node_modules/.bin/electron",
      "windows": {
        "runtimeExecutable": "${workspaceRoot}/node_modules/.bin/electron.cmd"
      },
      "args": ["."],
      "outputCapture": "std"
    }
  ]
}
```

配置解释：

```txt
name：用于识别启动项目 type：调试环境，这里是 Node
runtimeExecutable：指向批处理文件，用于启动 Electron
${workspaceRoot}：正在进行调试的程序的工作目录的绝对路径
args：启动参数，这里简写为 . ，其实是 index.js
```

配置完毕后，设置一个端点，在 debug 界面，即可点击绿色三角开始调试，如图所示：  
![electron debug 1](../images/electron/01.png)

调试结果如图所示，鼠标移入对象时，可以显示其属性，也可以在底部的调试栏中输入对象（示例中是 mainWindow）：

![electron debug 2](../images/electron/02.png)

### 2.2 调试渲染进程

渲染进程的调试工机具其实就是 Chrome 开发者工具，使用命令：`Ctrl+Shift+I`可以打开，Mac 下为：`Command+Option+I`。

也可以在`main.js`的代码中手动添加打开代码：

```js
// 打开开发者工具，书写在 loadFile 函数之后
mainWindow.webContents.openDevTools()
```

### 2.3 浏览器 debug 主进程

浏览器也可以用来调试主进程。在启动脚本中添加如下参数：

```txt
"dev": "electron --inspect=5858 ."
```

Electron 项目启动后，打开 Chrome 浏览器，输入 `chrome://inspect`，点击 `Configure` 后，输入配置的端口 `localhost:5858` 即可，此时浏览器会连接该程序。

## 三 进程间的消息传递

### 3.0 Electron 进程通信机制

Electron 使用 IPC（interprocess communication）在进程之间进行通信。

![electron debug 2](../images/electron/03.png)

### 3.1 渲染进程向主进程发送消息

`index.html`中发送数据：

```html
<button id="btn">操作</button>
<script>
  const { ipcRenderer } = require('electron')
  document.querySelector('#btn').addEventListener('click', function () {
    ipcRenderer.send('msg_renderUsers', { name: 'lisi' }, { age: 30 }) // 参数可以是多个
  })
</script>
```

注意：**如果出现类似 fs. 错误，则使用 window.require() 即可**

主进程 `main.js`中接收数据：

```js
// 主进程添加的消息处理代码
let { ipcMain } = require('electron')
ipcMain.on('msg_renderUsers', (event, param1, param2) => {
  // event.sender 是渲染进程的 webContents 实例
  console.log('param1：', param1)
  console.log('param2：', param2)
})
```

上述示例在 vscode 的调试模式下，即可在控制台看到打印。这里第一个参数即消息管道的名称，渲染进程的发送管道与主进程的接收管道必须一致，才能进行通信。当然也可以多处监听同一管道的代码，此时若该管道消息发来，则会触发多处监听事件。

无论是渲染进程和主进程谁主动发送，其背后的原理都是进程间通信：**发送的 json 对象被序列化，然后反序列化！所以发送对象原型链上的数据不会被发送**。

上述传递消息的方式是异步的，使用`ipcRenderer.sendSyc`可以同步发送，但是会阻塞渲染进程。

### 3.2 主进程向渲染进程发送消息

主进程 `main.js` 代码：

```js
let { ipcMain } = require('electron')
ipcMain.on('msg_renderUsers', (event, param1, param2) => {
  console.log('param1：', param1)
  console.log('param2：', param2)
  param2.age += 100
  mainWindow.webContents.send('msg_main2View', param1, param2)
})
```

渲染进程中接收：

```html
<button id="btn">操作</button>
<script>
  const { ipcRenderer } = require('electron')
  document.querySelector('#btn').addEventListener('click', function () {
    ipcRenderer.send('msg_renderUsers', { name: 'lisi' }, { age: 30 })
  })
  ipcRenderer.on('msg_main2View', (event, param1, param2) => {
    console.log('param1：', param1)
    console.log('param2：', param2)
  })
</script>
```

上述代码完成了主进程向渲染进程发送消息，渲染进程监听的效果。

### 3.3 多个渲染窗口响应主进程消息

如果打开了新的窗口，新窗口加载同样的页面，设置同样的监听函数，如果主进程再次发送消息，这个新窗口是不会触发监听事件的，因为主进程中使用的是`mainWindow.webContents.send`。

主进程接收消息事件的`event.sender`代表发送消息的渲染进程的`webContents`，可以通过该对象来给对应窗口发送消息：

```js
ipcMain.on('msg_renderUsers', (event, param1, param2) => {
  console.log('param1：', param1)
  console.log('param2：', param2)
  param2.age += 100
  event.sender.send('msg_main2View', param1, param2) // 也可以同理使用：event.reply("msg_main2View", param1, param2)
})
```

贴士：对于同步消息来说，其发送的返回值即是主进程响应的消息，如：`let res = ipcRenderer.sendSync('msg', {name: "lisi"})`

### 3.4 渲染进程之间消息传递

多个窗口之间进行消息传递，最常见的方式是：通过主进程进行中转。因为往往需要传递的时候，正式窗口新建立的时候。

如果已经得知要接收消息的窗口的`webContents`的 id，也可以直接传递：

```js
ipcRenderer.sendTo(win.webContents.id, 'msg', { name: 'lisi' }) // win 即目标窗口
```

## 四 remote 模块

### 4.1 remote 模块访问主进程

remote 模块可以帮助开发者在渲染进程中访问主进程对象。

在`index.html`中增加如下代码：

```html
<button id="openView">打开百度</button>
<script>
  const { remote } = require('electron')
  const BrowserWindow = remote.BrowserWindow
  document.querySelector('#openView').addEventListener('click', function () {
    let win = new BrowserWindow({ width: 800, height: 600 })
    win.loadURL('https://www.baidu.com')
  })
</script>
```

重启或者重新调试，即可看到界面。但是这里要注意的是**由于安全原因，Electron10 默认关闭了 remote，需要开启**，开启方式是在`main.js`中添加：

```js
mainWindow = new BrowserWindow({
  webPreferences: {
    nodeIntegration: true, // 允许界面使用 node
    enableRemoteModule: true, // 开启 remote 模块，Electron10 这里默认是 false
  },
})
```

remote 对象的属性和方法都是主进程的属性和方法的映射，使用 remote 访问主进程时，Electron 内部会构造一个消息，这个消息从渲染进程传送给主进程，主进程完成操作后，再以远程对象的形式传递给渲染进程。

上述代码中，新的 `BrowserWindow` 并不是渲染进程创建的，remote 模块通知主进程，主进程完成窗口实例的创建后，以实例以远程对象的形式返回给渲染进程。这些工作是 Electron 内部完成的！

### 4.2 remote 模块局限性

remote 模块可以降低主进程与渲染进程之间访问的难度，但是也带来了相当多的问题，在 Electron10 中，该模块已经被默认关闭：

- 性能损耗很大：跨进程操作的性能损耗是计算机中最严重的性能消耗点之一。
- 容易产生错误：
- 如：remote 模块使用了主进程某个对象，该对象在某一时刻会触发事件，但是事件处理程序位于渲染进程，这时候消息传递造成的延时很容易让渲染进程中一些代码失效，如：`event.preventDefault()`
- 如：remote 模块的对象其实是代理对象，并不是真实的原始对象。代理对象原型链上的属性不会映射到渲染进程的代理对象上。其次，类似 NaN、Infinity 这些值不能被正确的映射到渲染进程，如果一个主进程方法返回 NaN，则渲染进程 remote 模块获取的是 undefined。
- 安全问题：IPC 管道通信时，如果要加载第三方网页，恶意代码能够通过原型污染攻击来模拟 remote 模块的远程消息，以获取访问主进程模块的权利，从而逃离沙箱。

## 五 跨进程通信原理 Mojo 库

Mojo 框架 提供了消息管道、数据管道、共享缓存区等 IPC 实现，Chromium 在此基础上封装了一个进程间通讯工具适配不同语言，Electron 定义该封装的描述文件位于：`shell\common\api\api.mojom` 文件中，并包含以下 2 接口，与进程间通信有关：

```ts
interface ElectronRenderer {}
interface ElectronBrowser {}
```

Mojo 框架会实现上述接口，并将实现写入 `shell/api/api.mojjo.h` 文件中。在我们使用 js 代码 `ipcRenderer.invoke()` 向主进程通信时，实际执行的就是： `shell/renderer/api/electron_api_ipc_renderer.cc` 文件，该文件其实就引入了 mojo 实现的这个头文件！内部代码为：

```c++
// electron_browser_remote_ 对象其实就是Mojo通信对象
electron_browser_remote_->Invoke()
```

`electron*browser_remote_`对象调用 Invoke()方法后，Mojo 组织消息传递给主进程，主进程执行 `electron_api_web_content.cc` 文件内的 Invok()方法，该方法发射名为 `-ipc-invoke` 的事件，并且将渲染进程传来的数据一并发射出去。

事件的响应位于 `lib/browser/api/web-contents.ts`：

```ts
this.on('-ipc-invoke', function () {
  // ...
  event.sendReply() // 将处理结果返回给渲染进程，真实实现文件是 `shell/browser/api/event.cc`
})
```

该响应逻辑会查询执行用户注册的事件处理逻辑 Map 对象，若没找到则抛出异常。

贴士：用户是通过 `ipcMain.handle` 方法注册的处理逻辑，位于`lib/browser/ipc-main-impl.ts`
