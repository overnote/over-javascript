# 04-面向对象基础

## 一 封装

### 1.1 类的定义

```ts
class Person {
    // TS 中必须先定义好成员变量
    name: string
    age: number

    constructor(a: string, b: number) {
        this.name = a
        this.age = b
    }

    info(): void {
        console.log(this.name + '的年龄是：' + this.age)
    }
}

let p = new Person('张三', 40)
p.info()
```

注意：TS 一样支持 ES6 中的 extends 关键字

### 1.2 属性修饰符

权限修饰符：

```txt
public：        默认的修饰符，可以不写，在类里面、子类、类外面都可以访问
private：       只能在类定义里面访问，子类、类外部都没法访问
protected：     在类里面、子类里面可以访问，类外部无法访问
```

注意：在新规 ES 新提案中，使用 # 代表私有属性，TS 也必定会追随该提案。

此外：TS 也支持 static、get、set、readonly 等修饰符。

在 TS 中使用 get、set 示例：

```ts
class Employee {
    private _salary: number
    name: string
    get salary(): number {
        return this._salary
    }
    set salary(num) {
        this._salary = num
    }
}
```

## 二 继承

TS 中的继承与 ES6 一致，使用 extends 关键字即可。

```js
class Animal {
    name: string
    constructor(name: string) {
        this.name = name
    }
    run() {
        console.log(`${this.name} is running....`)
    }
}

class Dog extends Animal {
    constructor(name: string) {
        // 调用父类构造函数实现子类属性初始化
        super(name)
    }
}

let d = new Dog('大黄')
d.run()
```

## 三 多态

多态：父类型的引用指向了子类型的对象。

```ts
class Animal {
    name: string
    constructor(name: string) {
        this.name = name
    }
    run() {
        console.log(`${this.name} is running....`)
    }
}

class Dog extends Animal {
    constructor(name: string) {
        super(name)
    }
    run(distance: number = 10) {
        console.log(`${this.name} running ${distance} `)
    }
}

class Pig extends Animal {
    constructor(name: string) {
        super(name)
    }
    run(distance: number = 5) {
        console.log(`${this.name} running ${distance} `)
    }
}

// let d = new Dog("大黄")
// d.run()

let t1: Animal = new Dog('大黄')
t1.run()

let t2: Animal = new Pig('猪九戒')
t2.run()
```

上述案例中，无论是 t1，还是 t2，他们是不同的子类，但是都可以使用父类的类型来使用：

```ts
function showName(animal: Animal) {
    console.log(animal.name)
}
showName(t1)
showName(t2)
```

## 四 抽象类

如果很多类有共同性，可以使用抽象类来描述。

```ts
abstract class Animal {
    weight: number
    // 普通方法：有具体的实现
    eat() {
        console.log('eat...')
    }
    // 抽象方法：不能有具体的实现。抽象方法只能出现在抽象类中
    abstract move()
}
```

抽象类一般是不能用来实例化的，只能被继承，继承者必须实现抽象类的抽象方法：

```ts
class Bird extends Animal {
    move() {
        console.log('fly....')
    }
}

class Fish extends Animal {
    move() {
        console.log('swim....')
    }
}
```
